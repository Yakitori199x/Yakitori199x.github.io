{"pages":[],"posts":[{"title":"Java 8 in action 学习笔记(3)","text":"Java 8 in action 第八章、第九章学习笔记 Chapter 8. Refactoring, testing, and debuggingAnonymous classes &amp; Lambda expressions (8.1.2) Inside an anonymous class, this refers to the anonymous class itself, but inside a lambda it refers to the enclosing class. Anonymous classes are allowed to shadow variables from the enclosing class. Lambda expressions can’t (they’ll cause a compile error). 123456789101112131415int a = 10;// LambdaRunnable r1 = () -&gt; { int a = 2; // Compile error System.out.println(a);};// Anonymous classRunnable r2 = new Runnable() { public void run() { int a = 2; // fine! System.out.println(a); }}; Converting an anonymous class to a lambda expression can make the resulting code ambiguous in the context of overloading. 1234567891011121314151617181920212223interface Task{ // execute() has the same signature as run() in Runnable public void execute();}// there are 2 overloaded methods inside a classpublic static void doSomething(Runnable r){ r.run(); }public static void doSomething(Task a){ r.execute(); }// Anonymous class// will call doSomething(Task)doSomething(new Task() { public void execute() { System.out.println(&quot;Danger danger!!&quot;); }});// Lambda// Both doSomething(Task) and doSomething(Runnable) matchdoSomething(() -&gt; System.out.println(&quot;Danger danger!!&quot;));// The ambiguity can be solved by explicit castdoSomething((Task)() -&gt; System.out.println(&quot;Danger danger!!&quot;)); Conditional deferred execution (8.1.5)1234567891011121314151617181920212223// Example 1// 1. The state of the logger (what level it supports) is exposed in the client code through the method isLoggable.// 2. Query the state of the logger object every time before you can log a message// 如果需要在多处进行log，就要将这个逻辑重复多次，相当繁琐if (logger.isLoggable(Log.FINER)){ logger.finer(&quot;Problem: &quot; + generateDiagnostic());}// Example 2// 这种写法使得需要log不同级别的日志时，只需要修改一下Level.xxx即可。// Unfortunately, there’s still an issue with this code. The logging message is always evaluated, even if the logger isn’t enabled for the message level passed as argument.logger.log(Level.FINER, &quot;Problem: &quot; + generateDiagnostic());// Example 3// lambda实现了当log level匹配时，log信息才会被生成。// 如果你发现代码中多次出现了判断某个instance的状态，仅为了进入condition去调用某些method的模式，就可以考虑引入一个新的method和lambda，将上述操作封装在新method里。public void log(Level level, Supplier&lt;String&gt; msgSupplier) { if (logger.isLoggable(level)){ log(level, msgSupplier.get()); }}logger.log(Level.FINER, () -&gt; &quot;Problem: &quot; + generateDiagnostic()); Design Pattern – Strategy (8.2.1)123456789101112131415161718192021// 通过functional interface + lambda可以快速定义多个strategy。// 同时，让client class调用interface中的abstract method。// 这样就可以通过传入不同的lambda来改变method的行为，从而实现在runtime确定究竟执行哪一套逻辑。public interface ValidationStrategy { boolean execute(String s);}public class Validator { private final ValidationStrategy strategy; public Validator (ValidationStrategy v) this.strategy = v; public boolean validate (String s) { return strategy.execute(s); }}Validator numericValidator = new Validator((String s) -&gt; s.matches(&quot;[0-9]+&quot;));boolean b1 = numericValidator.validate(&quot;aaaa&quot;); // return falseValidator lowerCaseValidator = new Validator((String s) -&gt; s.matches(&quot;\\\\d+&quot;));boolean b2 = lowerCaseValidator.validate(&quot;bbbb&quot;); // return true Chain of responsibility (8.2.4)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// One processing object may do some work and pass the result to another object, which then also does some work and passes it on to yet another processing object, and so on.// Generally, this pattern is implemented by defining an abstract class representing a processing object that defines a field to keep track of a successor. Once it has finished its work, the processing object hands over its work to its successor.// abstract class represents the processing objectpublic abstract class ProcessingObject&lt;T&gt; { // to track the successor object which will do further processing based on current result protected ProcessingObject&lt;T&gt; successor; public void setSuccessor(ProcessingObject&lt;T&gt; successor) { this.successor = successor; } public T handle(T input) { T r = handleWork(input); if (successor != null) { return successor.handle(r); } return r; } abstract protected T handleWork(T input);}public class HeaderTextProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return &quot;From Raoul, Mario and Alan: &quot; + text; }}public class SpellCheckerProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;); }}// Use in clientProcessingObject&lt;String&gt; p1 = new HeaderTextProcessing();ProcessingObject&lt;String&gt; p2 = new SpellCheckerProcessing();p1.setSuccessor(p2);String result1 = p1.handle(&quot;Aren't labdas really sexy?!!&quot;); // Result: From Raoul, Mario and Alan: Aren't lambda really sexy?!!// Turn to lambda implementationUnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);String result2 = pipeline.apply(&quot;Aren't labdas really sexy?!!&quot;); Chapter 9. Default methodsBinary Compatible (9.1.2)Adding a new method to an interface is binary compatible; this means existing class file implementations will still run without the implementation of the new method, if there’s no attempt to recompile them. If the user modify the code to use the new method (say setRelativeSize), an error will be thrown at run-time because the setRelativeSize method isn’t implemented: 12Exception in thread &quot;main&quot; java.lang.AbstractMethodError: lambdasinaction.chap9.Ellipse.setRelativeSize(II)V If the user tries to rebuild his entire application, he’ll get the following compile error: 1lambdasinaction/chap9/Ellipse.java:6: error: Ellipse is not abstract and does not override abstract method setRelativeSize(int,int) in Resizable Source compatibility &amp; Behavioral compatibility Source compatibility: source compatibility means an existing program will still compile after introducing a change.(e.g. adding a method to an interface isn’t source compatible) Behavioral compatibility: behavioral compatibility means running a program after a change with the same inputs results in the same behavior.(e.g. adding a method to an interface is behavioral compatible because the method is never called in the program) Resolution rules (9.4) Classes always win. A method declaration in the class or a superclass takes priority over any default method declaration. Otherwise, sub-interfaces win: the method with the same signature in the most specific default-providing interface is selected. (If B extends A, B is more specific than A). Finally, if the choice is still ambiguous, the class inheriting from multiple interfaces has to explicitly select which default method implementation to use by overriding it and calling the desired method explicitly. 12345678910111213141516171819202122232425262728293031323334// Example 1// A is an interface with method hello(), B is another interface extends A and override hello(), D is a class implements Apublic class D implements A {}public class C extends D implements B, A { public static void main (String[] args) { // hello() from B is called // Because D doesn’t override hello although it has a default method from interface A. And B is more specfic than A. new C().hello(); }}// Example 2public interface A { void hello() { System.out.println(&quot;Hello from A&quot;); }}public interface B { void hello() { System.out.println(&quot;Hello from B&quot;); }}// Error: class C inherits unrelated defaults for hello() from types B and A.public class C implements B, A { }// Solution: use X.super.m() where X is the superinterface whose method m you want to call.public class C implements B, A { void hello() { B.super.hello(); // explicitly choose to call hello() from B }}","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_8_9/"},{"title":"Java 8 in action 学习笔记(2)","text":"Java 8 in action 第六章、第七章学习笔记 Chapter 6. Collecting data with streamsJoining Strings (6.2.3)The collector returned by the joining factory method concatenates into a single string all strings resulting from invoking the toString method on each object in the stream. 1String shortMenu = menu.stream().map(Dish::getName).collect(joining()); Note that joining internally makes use of a StringBuilder to append the generated strings into one. It also has an overloaded version that accepts a delimiter string between two consecutive elements. 123String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;));// Result:// pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon Collect vs. reduce123456789Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();List&lt;Integer&gt; numbers = stream.reduce( new ArrayList&lt;Integer&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; { l.add(e); return l; }, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; { l1.addAll(l2); return l1; }); The semantic problem: reduce method is meant to combine two values and produce a new one; it’s an immutable reduction. In contrast, the collect method is designed to mutate a container to accumulate the result it’s supposed to produce. The practical problem: this reduction process can’t work in parallel because the concurrent modification of the same data structure operated by multiple threads can corrupt the List itself. Multilevel grouping (6.3.1)You can achieve multilevel grouping by using a collector created with a two-argument version of the Collectors.groupingBy factory method, which accepts a second argument of type collector besides the usual classification function. 123456789101112131415161718192021public enum CaloricLevel { DIET, NORMAL, FAT };Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect( // outer collector with classification function groupingBy(Dish::getType, // inner collector groupingBy(dish -&gt; { if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }) ) )/* * Result will be like: * {MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]}, * FISH={DIET=[prawns], NORMAL=[salmon]}, * OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}} */ The regular one-argument groupingBy(f), where f is the classification function, is in reality just shorthand for groupingBy(f, toList()). More generally, the second collector passed to the first groupingBy can be any type of collector, not just another groupingBy. 123456789101112131415// count the number of Dishes in the menu for each type// {MEAT=3, FISH=2, OTHER=4}Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect( groupingBy(Dish::getType, counting()));// find the highest-calorie dish in the menu// {FISH=salmon, OTHER=pizza, MEAT=pork}// 因为maxBy返回的是Optional，此处需要用collectingAndThen将maxBy和Optional::get包起来// 其中，maxBy返回一个collector，Optional::get是transformation function，collectingAndThen也返回一个collector。Map&lt;Dish.Type, Dish&gt; mostCaloricType = menu.stream() .collect(groupingBy(Dish::getType, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get))); Chapter 7. Parallel data processing and performanceparallel() (7.1.1)In reality, calling the method parallel on a sequential stream doesn’t imply any concrete transformation on the stream itself. Internally, a boolean flag is set to signal that you want to run in parallel all the operations that follow the invocation to parallel. For the code: 123456stream.parallel() .filter(...) .sequential() .map(...) .parallel() .reduce(); Only the last call to parallel or sequential wins and affects the pipeline globally. Threads on multiple cores (7.1.2)Moving data between multiple cores is also more expensive than you might expect, so it’s important that work to be done in parallel on another core takes longer than the time required to transfer the data from one core to another. ForkJoinPool (7.2.1) Note that in a real-world application, it doesn’t make sense to use more than one ForkJoinPool. For this reason, what you typically should do is instantiate it only once and keep this instance in a static field, making it a singleton, so it could be conveniently reused by any part of your software. Invoking the join method on a task blocks the caller until the result produced by that task is ready. For this reason, it’s necessary to call it after the computation of both subtasks has been started. Calling the fork method on a subtask is the way to schedule it on the ForkJoinPool. It might seem natural to invoke it on both the left and right subtasks,** but this is less efficient than just directly calling compute on one of them.** Doing this allows you to reuse the same thread for one of the two subtasks and avoid the overhead caused by the unnecessary allocation of a further task on the pool. Work stealing (7.2.3)Ideally you want to partition the workload of a parallelized task in a way that each subtask takes exactly the same amount of time, keeping all the cores of your CPU equally busy. However, the time taken by each subtask can dramatically vary either due to the use of an inefficient partition strategy or because of unpredictable causes like slow access to the disk or the need to coordinate the execution with external services. The fork/join framework works around this problem with a technique called work stealing. Each of the threads holds a doubly linked queue of the tasks assigned to it, and as soon as it completes a task it pulls another one from the head of the queue and starts executing it. One thread might complete all the tasks assigned to it much faster than the others, in this case, instead of becoming idle, the thread randomly chooses a queue of a different thread and “steals” a task, taking it from the tail of the queue. It’s why having many smaller tasks, instead of only a few bigger ones, can help in better balancing the workload among the worker threads. More generally, this work-stealing algorithm is used to redistribute and balance the tasks among the worker threads in the pool.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_6_7/"},{"title":"Java 8 in action 学习笔记(1)","text":"Java 8 in action 第一章至第三章学习笔记 Chapter 1. Java 8: why should you care?Stream in Unix commands (1.1.2)Note that in Unix the commands (cat, tr, sort, and tail) are executed concurrently, so that sort can be processing the first few lines before cat or tr has finished. (P.s. 如同一个流水线一样，在Step1处理的同时，就将其已经生成的一部分结果输入到Step2去处理。） Optional (1.5)Optional includes methods to explicitly deal with the case where a value is absent, and as a result you can avoid NullPointer exceptions. Chapter 2. Passing code with behavior parameterizationBehavior parameterizationBehavior parameterization is a software development pattern that lets you handle frequent requirement changes. In a nutshell, it means taking a block of code and making it available without executing it. This block of code can be called later by other parts of your programs, which means that you can defer the execution of that block of code. For instance, you could pass the block of code as an argument to another method that will execute it later. As a result, the method’s behavior is parameterized based on that block of code. Behavior parameterization的发展（Java）- 以filterApples为例 如果想要以不同标准（颜色，重量…）来过滤🍎，最笨拙的方法是定义多个相似但带有不同判断逻辑的method，这样会使得代码非常冗余且难以维护。 作为改进，可以定义一个Predicate interface，然后定义多个不同的class去implement这个interface。filterApples method则可以接收Predicate的instance作为参数来实现behavior parameterization，behavior是通过被wrap在instance中来实现传递的。 但以上方法还是需要定义多个classes，其中很多可能仅仅使用了一次。为了减少verbosity，引入了anonymous class，允许程序员定义ad hoc classes。 不过anonymous class还是有一部分冗余的地方，比如每次都要声明父类和需要override的方法。lambda expression的出现进一步简化了这一问题，之后还衍生出更加简洁的method reference。 Chapter 3. Lambda expressionsLambda syntax (Quiz 3.1)123456789// Illegal, return is a control-flow statement.// It should be (Integer i) -&gt; {return &quot;Alan&quot; + i;}(Integer i) -&gt; return &quot;Alan&quot; + i;// Illegal, “Iron Man” is an expression, not a statement.// It should be (String s) -&gt; &quot;Iron Man&quot; or (String s) -&gt; {return &quot;Iron Man&quot;;}.(String s) -&gt; {&quot;Iron Man&quot;;}// p.s. 如果是statement，就算只有一句也要加上block Functional interfaces and Lambda expressions (3.2.1)Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline and treat the whole expression as an instance of a functional interface (more technically speaking, an instance of a concrete implementation of the functional interface). Execute around pattern (3.3)A recurrent pattern in resource processing (for example, dealing with files or databases) is to open a resource, do some processing on it, and then close the resource. The setup and cleanup phases are always similar and surround the important code doing the processing. This is called the execute around pattern. 1234567891011121314151617// execute around pattern很适合用lambda进行behavior parameterization// define functional interfacepublic interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException;}// define the method accept instance of the functional interfacepublic static String processFile (BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) { return p.process(br); }}// pass lambda expressionsString oneLine = processFile((BufferedReader br) -&gt; br.readLine());String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); Primitive specializations (3.4.3)Boxed values are essentially a wrapper around primitive types and are stored on the heap. Therefore, boxed values use more memory and require additional memory lookups to fetch the wrapped primitive value. Java 8 brings a specialized version of the functional interfaces in order to avoid autoboxing operations when the inputs or outputs are primitives. 1234567// no boxingIntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;evenNumbers.test(1000);// with boxingPredicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % 2 == 1;oddNumbers.test(1000) type-checking process (3.5.1)Use filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150); as an example. First, you look up the declaration of the filter method. (filter(List&lt;Apple&gt; inventory, Predicate&lt;Apple&gt; p)) Second, it expects as the second formal parameter an object of type Predicate&lt;Apple&gt; (the target type ). Third, Predicate is a functional interface defining a single abstract method called test. Fourth, the method test describes a function descriptor that accepts an Apple and returns a boolean. Finally, any actual argument to the filter method needs to match this requirement. Special void-compatibility ruleIf a lambda has a statement expression as its body, it’s compatible with a function descriptor that returns void (provided the parameter list is compatible too). For example, both of the following lines are legal even though the method add of a List returns a boolean and not void as expected in the Consumer context (T -&gt; void): 12345// Predicate has a boolean returnPredicate&lt;String&gt; p = s -&gt; list.add(s);// Consumer has a void returnConsumer&lt;String&gt; b = s -&gt; list.add(s); Recipe for constructing method references A method reference to a static method (Integer::parseInt) A method reference to an instance method of an arbitrary type (String::length) A method reference to an instance method of an existing object (expensiveTransaction::getValue, expensiveTransaction is an instance of type Transaction) 12345678910111213141. A method reference to a static methodLambda: (args) -&gt; ClassName.staticMethod(args) Method reference: ClassName::staticMethode.g. (String s) -&gt; Integer.parseInt(s) =&gt; Integer::parseInt2. A method reference to an instance method of an arbitrary typeLambda: (arg0, rest) -&gt; arg0.instanceMethod(rest) // arg0 is an instance of ClassNameMethod reference: ClassName::instanceMethode.g. (String s) -&gt; s.length() =&gt; String::length3. A method reference to an instance method of an existing objectLambda: (args) -&gt; expr.instanceMethod(args) // expr is an instance of some classMethod reference: expr::instanceMethode.g. () -&gt; expensiveTransaction.getValue() =&gt; expensiveTransaction::getValue","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_1_3/"},{"title":"Java 8 in action 学习笔记(4)","text":"Java 8 in action 第十章、第十一章学习笔记 Chapter 10. Using Optional as a better alternative to nullProblems with null (10.1.2) It’s a source of error. NullPointerException is by far the most common exception in Java. It bloats your code. It worsens readability by making it necessary to fill your code with often deeply nested null checks. It’s meaningless. It doesn’t have any semantic meaning, and in particular it represents the wrong way to model the absence of a value in a statically typed language. It breaks Java philosophy. Java always hides pointers from developers except in one case: the null pointer. It creates a hole in the type system. null carries no type or other information, meaning it can be assigned to any reference type. This is a problem because, when it’s propagated to another part of the system, you have no idea what that null was initially supposed to be. Using optionals in a domain model and why they’re not Serializable (10.3.3)Optional class在设计的时候没有考虑直接用在filed type上，也就是说，它的预想用例并不是直接将fields直接声明为Optional。所以，Optional没有实现Serializable接口，意味着如果某个class包含了Optional field，序列化的过程就会失败。 如果你需要让你的model能够被序列化，一个可取的方法是fields的声明还是保持不变，但是在method上进行修改。比如以下的例子： 123456public class Person { private Car car; public Optional&lt;Car&gt; getCarAsOptional() { return Optional.ofNullable(car); }} 因为Person不一定都拥有Car，所以Car是存在缺失的可能的。这时我们不是将Car声明为Optional，而是在get method里返回Optional，同时兼顾了Optional和Serializable。getCarAsOptional()也提醒client，Car是可能缺失的这一层含义。 OrElseGetorElseGet(Supplier&lt;? extends T&gt; other) is the lazy counterpart of the orElse method, because the supplier is invoked only if the optional contains no value. You should use this method either when the default value is time-consuming to create (to gain a little efficiency) or you want to be sure this is done only if the optional is empty (in which case it’s strictly necessary). Chapter 11. CompletableFuture: composable asynchronous programmingSynchronous vs. Asynchronous API (11.1.2) Synchronous APIYou call a method, the caller then waits while the method computes, the method then returns, and the caller continues with the returned value. Even if the caller and callee were executed on different threads, the caller would still wait for the callee to complete; this gives rise to the phrase blocking call. Asynchronous APIThe method returns immediately, or at least before its computation is complete, delegating its remaining computation to a thread, which runs asynchronously to the caller, hence the phrase non-blocking call. Implementing an asynchronous API (11.2)在这个例子中，我们模拟通过service提供的API来获取对应产品的价格，最终计算出价格最便宜的产品的情景。 首先，我们给出一个synchronous API的实现： 1234567891011121314151617public double getPrice(String product) { return calculatePrice(product);}private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1);}// delay用于模拟请求API到获得结果所花费的时间public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); }} 这个synchronous API的实现有如下弊端： When the consumer of this API (the best-price-finder application) invokes this method, it will remain blocked and then idle for 1 second while waiting for its synchronous completion. This is unacceptable, especially considering that the best-price-finder application will have to repeat this operation for all the shops in its network. 因此，我们需要做出一些改进，将其实现为asynchronous API，具体实现如下： 123456789101112131415161718public Future&lt;Double&gt; getPriceAsync(String product) { CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread ( () -&gt; { try { double price = calculatePrice(product); // Set the value returned by the long computation when it becomes available futurePrice.complete(price); } catch (Exception ex) { // Complete it exceptionally with the Exception caused the failure futurePrice.completeExceptionally(ex); } }).start(); // Return the Future without waiting for the computation of the result it contains return futurePrice;} 其中需要注意的是asynchronous task也是有可能出现错误的，虽然我们可以在获取Future的结果时设定一个timeout来避免无限地等待，但是这种方法最终只会throw TimeoutException，对于定位真正造成failure的原因是没有帮助的。因此，将Exception保存在Future里是更合理的做法。 最后，我们还可以通过supplyAsync factory method来更简洁地实现与上面的代码相同效果的代码（包括返回的结果和error management）： 123public Future&lt;Double&gt; getPriceAsync(String product) { return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));} Parallel and Asynchronous (11.3)首先，我们假定shop提供的商品价格获取API都是synchronous的，那么一种方式是使用parallel stream： 12345public List&lt;String&gt; findPrice(String product) { return shops.stream() .map(shop -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());} 还有一种方式就是使用异步请求CompletableFuture： 123456789101112131415161718public List&lt;String&gt; findPrice(String product) { List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product)) )) .collect(Collectors.toList()); /* * 这里分为两个stream进行处理的原因是: * 如果在第一个stream处直接接上map(CompletableFuture::join)， * 会造成向shop1发送getPrice的请求并返回future后，马上就调用join把当前thread阻塞，去等待shop1返回的结果。 * 导致执行过程变为shop1.getprice() -&gt; join() -&gt; shop2.getprice() -&gt; join -&gt; ...， * 没有真正利用到async的特点。 */ return priceFutures.stream() .map(CompletableFuture::join) .collect(Collectors.toList());} 当shop的数量为4且两个方法在4核CPU上运行时，parallel的方法耗时约为1s，而async方法耗时约为2s。这里是因为async需要threads之间的对CPU和内存的竞争以及上下文切换的开销。如果存在5个shop，那么parallel的情况下需要耗时约2s，因为需要等待4个先前的并行任务中的某个完成后才能发起新的task。相比之下，async可以通过定义custom executor的方式来scale。 123456789101112131415161718192021private final Executor executor = Executors.newFixedThreadPool( // 防止shops数量过多使得线程池可允许的threads数量太多 // threads数量太多会造成大量对CPU和内存的竞争以及上下文切换的开销 Math.min(shops.size(), 100), new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); /* * A Java program can’t terminate or exit while a normal thread is executing, * so a leftover thread waiting for a never-satisfiable event causes problems. * By contrast, marking a thread as a daemon means it can be killed on program termination. */ thread.setDaemon(true); return thread; } });// 将custom executor用于findPrice中的CompletableFutureCompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product), executor); 在使用custom executor的情况下，async方法中可以发起的threads数量不再局限于CPU核心数，再加上getPrice主要是Network I/O，即等待远端服务器计算返回结果，thread自身只负责发起请求但没有密集的计算，即使shops数量达到400，也可以在约为1s内获得所有的prices。 对于使用parallel还是async，主要取决于task是以compute为主，还是以wait为主： If you’re doing computation-heavy operations with no I/O, then the Stream interface gives the simplest implementation and one likely to be the most efficient (if all threads are compute-bound, then there’s no point in having more threads than processor cores). On the other hand, if your parallel units of work involve waiting for I/O (including network connections), then CompletableFutures give more flexibility and the ability to match the number of threads to the wait/computer, or W/C, ratio. Combine independent asynchronous tasks (11.4)One frequently occurring case is where you need to combine the results of the operations performed by two completely independent CompletableFutures, and you don’t want to wait for the first to complete before starting on the second. Turning to our running example, you may know that one of the shops provides prices in €(EUR), but you always want to communicate them in $ (USD) to your customers. You can asynchronously ask the shop the price of a given product and retrieve, from a remote exchange-rate service, the current exchange rate between € and $. After both have completed, you can combine the results by multiplying the price by the exchange rate. The implementation could be: 1234567Future&lt;Double&gt; futurePriceInUSD = CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product)) .thenCombine( CompletableFuture.supplyAsync( () -&gt; exchangeService.getRate(Money.EUR, Money.USD)), (price, rate) -&gt; price * rate ); The workflow of combining these two asynchronous tasks should be: Reacting to a CompletableFuture completion (11.5)在一般情况下，向不同的shop请求getPrice，响应时间也各不相同。有时候我们想要实现一旦从某个shop获取的price被返回，我们就可以立刻使用这个price，而不需要等待所有tasks都被完成后再进行下一步处理。在这种场景下，我们可以使用thenAccept方法。 12345678910111213141516171819202122public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product) { return shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product), executor)) .map(future -&gt; future.thenApply(Quote::parse)) .map(future -&gt; future.thenCompose( quote -&gt; CompletableFuture.supplyAsync( () -&gt; Discount.applyDiscount(quote), executor)));}CompletableFuture[] futures = findPricesStream(&quot;myPhone&quot;) .map(f -&gt; f.thenAccept(System.out::println)) .toArray(size -&gt; new CompletableFuture[size]);/* * The allOf factory method * Input: an array of CompletableFutures * Return: CompletableFuture&lt;Void&gt; * that’s completed only when all the CompletableFutures passed have completed. * There is another method called anyOf() * it waits for the completion of only one of the CompletableFutures in an array. */CompletableFuture.allOf(futures).join(); thenAccept() operation simply registers an action on each CompletableFuture; this action consumes the value of the CompletableFuture as soon as it completes. It also has an Async variant schedules the execution of the Consumer passed to it on a new thread from the thread pool instead of directly performing it using the same thread that completed the CompletableFuture. Because the thenAccept method already specifies how to consume the result produced by the CompletableFuture when it becomes available, it returns a Completable-Future.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_10_11/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Optional","slug":"Optional","link":"/tags/Optional/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java 8 in action","slug":"读书笔记/Java-8-in-action","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8-in-action/"}]}