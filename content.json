{"pages":[],"posts":[{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(3)","text":"Java 8 in action ç¬¬å…«ç« ã€ç¬¬ä¹ç« å­¦ä¹ ç¬”è®° Chapter 8. Refactoring, testing, and debuggingAnonymous classes &amp; Lambda expressions (8.1.2) Inside an anonymous class, this refers to the anonymous class itself, but inside a lambda it refers to the enclosing class. Anonymous classes are allowed to shadow variables from the enclosing class. Lambda expressions canâ€™t (theyâ€™ll cause a compile error). 123456789101112131415int a = 10;// LambdaRunnable r1 = () -&gt; { int a = 2; // Compile error System.out.println(a);};// Anonymous classRunnable r2 = new Runnable() { public void run() { int a = 2; // fine! System.out.println(a); }}; Converting an anonymous class to a lambda expression can make the resulting code ambiguous in the context of overloading. 1234567891011121314151617181920212223interface Task{ // execute() has the same signature as run() in Runnable public void execute();}// there are 2 overloaded methods inside a classpublic static void doSomething(Runnable r){ r.run(); }public static void doSomething(Task a){ r.execute(); }// Anonymous class// will call doSomething(Task)doSomething(new Task() { public void execute() { System.out.println(&quot;Danger danger!!&quot;); }});// Lambda// Both doSomething(Task) and doSomething(Runnable) matchdoSomething(() -&gt; System.out.println(&quot;Danger danger!!&quot;));// The ambiguity can be solved by explicit castdoSomething((Task)() -&gt; System.out.println(&quot;Danger danger!!&quot;)); Conditional deferred execution (8.1.5)1234567891011121314151617181920212223// Example 1// 1. The state of the logger (what level it supports) is exposed in the client code through the method isLoggable.// 2. Query the state of the logger object every time before you can log a message// å¦‚æœéœ€è¦åœ¨å¤šå¤„è¿›è¡Œlogï¼Œå°±è¦å°†è¿™ä¸ªé€»è¾‘é‡å¤å¤šæ¬¡ï¼Œç›¸å½“ç¹çif (logger.isLoggable(Log.FINER)){ logger.finer(&quot;Problem: &quot; + generateDiagnostic());}// Example 2// è¿™ç§å†™æ³•ä½¿å¾—éœ€è¦logä¸åŒçº§åˆ«çš„æ—¥å¿—æ—¶ï¼Œåªéœ€è¦ä¿®æ”¹ä¸€ä¸‹Level.xxxå³å¯ã€‚// Unfortunately, thereâ€™s still an issue with this code. The logging message is always evaluated, even if the logger isnâ€™t enabled for the message level passed as argument.logger.log(Level.FINER, &quot;Problem: &quot; + generateDiagnostic());// Example 3// lambdaå®ç°äº†å½“log levelåŒ¹é…æ—¶ï¼Œlogä¿¡æ¯æ‰ä¼šè¢«ç”Ÿæˆã€‚// å¦‚æœä½ å‘ç°ä»£ç ä¸­å¤šæ¬¡å‡ºç°äº†åˆ¤æ–­æŸä¸ªinstanceçš„çŠ¶æ€ï¼Œä»…ä¸ºäº†è¿›å…¥conditionå»è°ƒç”¨æŸäº›methodçš„æ¨¡å¼ï¼Œå°±å¯ä»¥è€ƒè™‘å¼•å…¥ä¸€ä¸ªæ–°çš„methodå’Œlambdaï¼Œå°†ä¸Šè¿°æ“ä½œå°è£…åœ¨æ–°methodé‡Œã€‚public void log(Level level, Supplier&lt;String&gt; msgSupplier) { if (logger.isLoggable(level)){ log(level, msgSupplier.get()); }}logger.log(Level.FINER, () -&gt; &quot;Problem: &quot; + generateDiagnostic()); Design Pattern â€“ Strategy (8.2.1)123456789101112131415161718192021// é€šè¿‡functional interface + lambdaå¯ä»¥å¿«é€Ÿå®šä¹‰å¤šä¸ªstrategyã€‚// åŒæ—¶ï¼Œè®©client classè°ƒç”¨interfaceä¸­çš„abstract methodã€‚// è¿™æ ·å°±å¯ä»¥é€šè¿‡ä¼ å…¥ä¸åŒçš„lambdaæ¥æ”¹å˜methodçš„è¡Œä¸ºï¼Œä»è€Œå®ç°åœ¨runtimeç¡®å®šç©¶ç«Ÿæ‰§è¡Œå“ªä¸€å¥—é€»è¾‘ã€‚public interface ValidationStrategy { boolean execute(String s);}public class Validator { private final ValidationStrategy strategy; public Validator (ValidationStrategy v) this.strategy = v; public boolean validate (String s) { return strategy.execute(s); }}Validator numericValidator = new Validator((String s) -&gt; s.matches(&quot;[0-9]+&quot;));boolean b1 = numericValidator.validate(&quot;aaaa&quot;); // return falseValidator lowerCaseValidator = new Validator((String s) -&gt; s.matches(&quot;\\\\d+&quot;));boolean b2 = lowerCaseValidator.validate(&quot;bbbb&quot;); // return true Chain of responsibility (8.2.4)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// One processing object may do some work and pass the result to another object, which then also does some work and passes it on to yet another processing object, and so on.// Generally, this pattern is implemented by defining an abstract class representing a processing object that defines a field to keep track of a successor. Once it has finished its work, the processing object hands over its work to its successor.// abstract class represents the processing objectpublic abstract class ProcessingObject&lt;T&gt; { // to track the successor object which will do further processing based on current result protected ProcessingObject&lt;T&gt; successor; public void setSuccessor(ProcessingObject&lt;T&gt; successor) { this.successor = successor; } public T handle(T input) { T r = handleWork(input); if (successor != null) { return successor.handle(r); } return r; } abstract protected T handleWork(T input);}public class HeaderTextProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return &quot;From Raoul, Mario and Alan: &quot; + text; }}public class SpellCheckerProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;); }}// Use in clientProcessingObject&lt;String&gt; p1 = new HeaderTextProcessing();ProcessingObject&lt;String&gt; p2 = new SpellCheckerProcessing();p1.setSuccessor(p2);String result1 = p1.handle(&quot;Aren't labdas really sexy?!!&quot;); // Result: From Raoul, Mario and Alan: Aren't lambda really sexy?!!// Turn to lambda implementationUnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);String result2 = pipeline.apply(&quot;Aren't labdas really sexy?!!&quot;); Chapter 9. Default methodsBinary Compatible (9.1.2)Adding a new method to an interface is binary compatible; this means existing class file implementations will still run without the implementation of the new method, if thereâ€™s no attempt to recompile them. If the user modify the code to use the new method (say setRelativeSize), an error will be thrown at run-time because the setRelativeSize method isnâ€™t implemented: 12Exception in thread &quot;main&quot; java.lang.AbstractMethodError: lambdasinaction.chap9.Ellipse.setRelativeSize(II)V If the user tries to rebuild his entire application, heâ€™ll get the following compile error: 1lambdasinaction/chap9/Ellipse.java:6: error: Ellipse is not abstract and does not override abstract method setRelativeSize(int,int) in Resizable Source compatibility &amp; Behavioral compatibility Source compatibility: source compatibility means an existing program will still compile after introducing a change.(e.g. adding a method to an interface isnâ€™t source compatible) Behavioral compatibility: behavioral compatibility means running a program after a change with the same inputs results in the same behavior.(e.g. adding a method to an interface is behavioral compatible because the method is never called in the program) Resolution rules (9.4) Classes always win. A method declaration in the class or a superclass takes priority over any default method declaration. Otherwise, sub-interfaces win: the method with the same signature in the most specific default-providing interface is selected. (If B extends A, B is more specific than A). Finally, if the choice is still ambiguous, the class inheriting from multiple interfaces has to explicitly select which default method implementation to use by overriding it and calling the desired method explicitly. 12345678910111213141516171819202122232425262728293031323334// Example 1// A is an interface with method hello(), B is another interface extends A and override hello(), D is a class implements Apublic class D implements A {}public class C extends D implements B, A { public static void main (String[] args) { // hello() from B is called // Because D doesnâ€™t override hello although it has a default method from interface A. And B is more specfic than A. new C().hello(); }}// Example 2public interface A { void hello() { System.out.println(&quot;Hello from A&quot;); }}public interface B { void hello() { System.out.println(&quot;Hello from B&quot;); }}// Error: class C inherits unrelated defaults for hello() from types B and A.public class C implements B, A { }// Solution: use X.super.m() where X is the superinterface whose method m you want to call.public class C implements B, A { void hello() { B.super.hello(); // explicitly choose to call hello() from B }}","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_8_9/"},{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(2)","text":"Java 8 in action ç¬¬å…­ç« ã€ç¬¬ä¸ƒç« å­¦ä¹ ç¬”è®° Chapter 6. Collecting data with streamsJoining Strings (6.2.3)The collector returned by the joining factory method concatenates into a single string all strings resulting from invoking the toString method on each object in the stream. 1String shortMenu = menu.stream().map(Dish::getName).collect(joining()); Note that joining internally makes use of a StringBuilder to append the generated strings into one. It also has an overloaded version that accepts a delimiter string between two consecutive elements. 123String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;));// Result:// pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon Collect vs. reduce123456789Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();List&lt;Integer&gt; numbers = stream.reduce( new ArrayList&lt;Integer&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; { l.add(e); return l; }, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; { l1.addAll(l2); return l1; }); The semantic problem: reduce method is meant to combine two values and produce a new one; itâ€™s an immutable reduction. In contrast, the collect method is designed to mutate a container to accumulate the result itâ€™s supposed to produce. The practical problem: this reduction process canâ€™t work in parallel because the concurrent modification of the same data structure operated by multiple threads can corrupt the List itself. Multilevel grouping (6.3.1)You can achieve multilevel grouping by using a collector created with a two-argument version of the Collectors.groupingBy factory method, which accepts a second argument of type collector besides the usual classification function. 123456789101112131415161718192021public enum CaloricLevel { DIET, NORMAL, FAT };Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect( // outer collector with classification function groupingBy(Dish::getType, // inner collector groupingBy(dish -&gt; { if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }) ) )/* * Result will be like: * {MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]}, * FISH={DIET=[prawns], NORMAL=[salmon]}, * OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}} */ The regular one-argument groupingBy(f), where f is the classification function, is in reality just shorthand for groupingBy(f, toList()). More generally, the second collector passed to the first groupingBy can be any type of collector, not just another groupingBy. 123456789101112131415// count the number of Dishes in the menu for each type// {MEAT=3, FISH=2, OTHER=4}Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect( groupingBy(Dish::getType, counting()));// find the highest-calorie dish in the menu// {FISH=salmon, OTHER=pizza, MEAT=pork}// å› ä¸ºmaxByè¿”å›çš„æ˜¯Optionalï¼Œæ­¤å¤„éœ€è¦ç”¨collectingAndThenå°†maxByå’ŒOptional::getåŒ…èµ·æ¥// å…¶ä¸­ï¼ŒmaxByè¿”å›ä¸€ä¸ªcollectorï¼ŒOptional::getæ˜¯transformation functionï¼ŒcollectingAndThenä¹Ÿè¿”å›ä¸€ä¸ªcollectorã€‚Map&lt;Dish.Type, Dish&gt; mostCaloricType = menu.stream() .collect(groupingBy(Dish::getType, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get))); Chapter 7. Parallel data processing and performanceparallel() (7.1.1)In reality, calling the method parallel on a sequential stream doesnâ€™t imply any concrete transformation on the stream itself. Internally, a boolean flag is set to signal that you want to run in parallel all the operations that follow the invocation to parallel. For the code: 123456stream.parallel() .filter(...) .sequential() .map(...) .parallel() .reduce(); Only the last call to parallel or sequential wins and affects the pipeline globally. Threads on multiple cores (7.1.2)Moving data between multiple cores is also more expensive than you might expect, so itâ€™s important that work to be done in parallel on another core takes longer than the time required to transfer the data from one core to another. ForkJoinPool (7.2.1) Note that in a real-world application, it doesnâ€™t make sense to use more than one ForkJoinPool. For this reason, what you typically should do is instantiate it only once and keep this instance in a static field, making it a singleton, so it could be conveniently reused by any part of your software. Invoking the join method on a task blocks the caller until the result produced by that task is ready. For this reason, itâ€™s necessary to call it after the computation of both subtasks has been started. Calling the fork method on a subtask is the way to schedule it on the ForkJoinPool. It might seem natural to invoke it on both the left and right subtasks,** but this is less efficient than just directly calling compute on one of them.** Doing this allows you to reuse the same thread for one of the two subtasks and avoid the overhead caused by the unnecessary allocation of a further task on the pool. Work stealing (7.2.3)Ideally you want to partition the workload of a parallelized task in a way that each subtask takes exactly the same amount of time, keeping all the cores of your CPU equally busy. However, the time taken by each subtask can dramatically vary either due to the use of an inefficient partition strategy or because of unpredictable causes like slow access to the disk or the need to coordinate the execution with external services. The fork/join framework works around this problem with a technique called work stealing. Each of the threads holds a doubly linked queue of the tasks assigned to it, and as soon as it completes a task it pulls another one from the head of the queue and starts executing it. One thread might complete all the tasks assigned to it much faster than the others, in this case, instead of becoming idle, the thread randomly chooses a queue of a different thread and â€œstealsâ€ a task, taking it from the tail of the queue. Itâ€™s why having many smaller tasks, instead of only a few bigger ones, can help in better balancing the workload among the worker threads. More generally, this work-stealing algorithm is used to redistribute and balance the tasks among the worker threads in the pool.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_6_7/"},{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(1)","text":"Java 8 in action ç¬¬ä¸€ç« è‡³ç¬¬ä¸‰ç« å­¦ä¹ ç¬”è®° Chapter 1. Java 8: why should you care?Stream in Unix commands (1.1.2)Note that in Unix the commands (cat, tr, sort, and tail) are executed concurrently, so that sort can be processing the first few lines before cat or tr has finished. (P.s. å¦‚åŒä¸€ä¸ªæµæ°´çº¿ä¸€æ ·ï¼Œåœ¨Step1å¤„ç†çš„åŒæ—¶ï¼Œå°±å°†å…¶å·²ç»ç”Ÿæˆçš„ä¸€éƒ¨åˆ†ç»“æœè¾“å…¥åˆ°Step2å»å¤„ç†ã€‚ï¼‰ Optional (1.5)Optional includes methods to explicitly deal with the case where a value is absent, and as a result you can avoid NullPointer exceptions. Chapter 2. Passing code with behavior parameterizationBehavior parameterizationBehavior parameterization is a software development pattern that lets you handle frequent requirement changes. In a nutshell, it means taking a block of code and making it available without executing it. This block of code can be called later by other parts of your programs, which means that you can defer the execution of that block of code. For instance, you could pass the block of code as an argument to another method that will execute it later. As a result, the methodâ€™s behavior is parameterized based on that block of code. Behavior parameterizationçš„å‘å±•ï¼ˆJavaï¼‰- ä»¥filterApplesä¸ºä¾‹ å¦‚æœæƒ³è¦ä»¥ä¸åŒæ ‡å‡†ï¼ˆé¢œè‰²ï¼Œé‡é‡â€¦ï¼‰æ¥è¿‡æ»¤ğŸï¼Œæœ€ç¬¨æ‹™çš„æ–¹æ³•æ˜¯å®šä¹‰å¤šä¸ªç›¸ä¼¼ä½†å¸¦æœ‰ä¸åŒåˆ¤æ–­é€»è¾‘çš„methodï¼Œè¿™æ ·ä¼šä½¿å¾—ä»£ç éå¸¸å†—ä½™ä¸”éš¾ä»¥ç»´æŠ¤ã€‚ ä½œä¸ºæ”¹è¿›ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªPredicate interfaceï¼Œç„¶åå®šä¹‰å¤šä¸ªä¸åŒçš„classå»implementè¿™ä¸ªinterfaceã€‚filterApples methodåˆ™å¯ä»¥æ¥æ”¶Predicateçš„instanceä½œä¸ºå‚æ•°æ¥å®ç°behavior parameterizationï¼Œbehavioræ˜¯é€šè¿‡è¢«wrapåœ¨instanceä¸­æ¥å®ç°ä¼ é€’çš„ã€‚ ä½†ä»¥ä¸Šæ–¹æ³•è¿˜æ˜¯éœ€è¦å®šä¹‰å¤šä¸ªclassesï¼Œå…¶ä¸­å¾ˆå¤šå¯èƒ½ä»…ä»…ä½¿ç”¨äº†ä¸€æ¬¡ã€‚ä¸ºäº†å‡å°‘verbosityï¼Œå¼•å…¥äº†anonymous classï¼Œå…è®¸ç¨‹åºå‘˜å®šä¹‰ad hoc classesã€‚ ä¸è¿‡anonymous classè¿˜æ˜¯æœ‰ä¸€éƒ¨åˆ†å†—ä½™çš„åœ°æ–¹ï¼Œæ¯”å¦‚æ¯æ¬¡éƒ½è¦å£°æ˜çˆ¶ç±»å’Œéœ€è¦overrideçš„æ–¹æ³•ã€‚lambda expressionçš„å‡ºç°è¿›ä¸€æ­¥ç®€åŒ–äº†è¿™ä¸€é—®é¢˜ï¼Œä¹‹åè¿˜è¡ç”Ÿå‡ºæ›´åŠ ç®€æ´çš„method referenceã€‚ Chapter 3. Lambda expressionsLambda syntax (Quiz 3.1)123456789// Illegal, return is a control-flow statement.// It should be (Integer i) -&gt; {return &quot;Alan&quot; + i;}(Integer i) -&gt; return &quot;Alan&quot; + i;// Illegal, â€œIron Manâ€ is an expression, not a statement.// It should be (String s) -&gt; &quot;Iron Man&quot; or (String s) -&gt; {return &quot;Iron Man&quot;;}.(String s) -&gt; {&quot;Iron Man&quot;;}// p.s. å¦‚æœæ˜¯statementï¼Œå°±ç®—åªæœ‰ä¸€å¥ä¹Ÿè¦åŠ ä¸Šblock Functional interfaces and Lambda expressions (3.2.1)Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline and treat the whole expression as an instance of a functional interface (more technically speaking, an instance of a concrete implementation of the functional interface). Execute around pattern (3.3)A recurrent pattern in resource processing (for example, dealing with files or databases) is to open a resource, do some processing on it, and then close the resource. The setup and cleanup phases are always similar and surround the important code doing the processing. This is called the execute around pattern. 1234567891011121314151617// execute around patternå¾ˆé€‚åˆç”¨lambdaè¿›è¡Œbehavior parameterization// define functional interfacepublic interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException;}// define the method accept instance of the functional interfacepublic static String processFile (BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) { return p.process(br); }}// pass lambda expressionsString oneLine = processFile((BufferedReader br) -&gt; br.readLine());String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); Primitive specializations (3.4.3)Boxed values are essentially a wrapper around primitive types and are stored on the heap. Therefore, boxed values use more memory and require additional memory lookups to fetch the wrapped primitive value. Java 8 brings a specialized version of the functional interfaces in order to avoid autoboxing operations when the inputs or outputs are primitives. 1234567// no boxingIntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;evenNumbers.test(1000);// with boxingPredicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % 2 == 1;oddNumbers.test(1000) type-checking process (3.5.1)Use filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150); as an example. First, you look up the declaration of the filter method. (filter(List&lt;Apple&gt; inventory, Predicate&lt;Apple&gt; p)) Second, it expects as the second formal parameter an object of type Predicate&lt;Apple&gt; (the target type ). Third, Predicate is a functional interface defining a single abstract method called test. Fourth, the method test describes a function descriptor that accepts an Apple and returns a boolean. Finally, any actual argument to the filter method needs to match this requirement. Special void-compatibility ruleIf a lambda has a statement expression as its body, itâ€™s compatible with a function descriptor that returns void (provided the parameter list is compatible too). For example, both of the following lines are legal even though the method add of a List returns a boolean and not void as expected in the Consumer context (T -&gt; void): 12345// Predicate has a boolean returnPredicate&lt;String&gt; p = s -&gt; list.add(s);// Consumer has a void returnConsumer&lt;String&gt; b = s -&gt; list.add(s); Recipe for constructing method references A method reference to a static method (Integer::parseInt) A method reference to an instance method of an arbitrary type (String::length) A method reference to an instance method of an existing object (expensiveTransaction::getValue, expensiveTransaction is an instance of type Transaction) 12345678910111213141. A method reference to a static methodLambda: (args) -&gt; ClassName.staticMethod(args) Method reference: ClassName::staticMethode.g. (String s) -&gt; Integer.parseInt(s) =&gt; Integer::parseInt2. A method reference to an instance method of an arbitrary typeLambda: (arg0, rest) -&gt; arg0.instanceMethod(rest) // arg0 is an instance of ClassNameMethod reference: ClassName::instanceMethode.g. (String s) -&gt; s.length() =&gt; String::length3. A method reference to an instance method of an existing objectLambda: (args) -&gt; expr.instanceMethod(args) // expr is an instance of some classMethod reference: expr::instanceMethode.g. () -&gt; expensiveTransaction.getValue() =&gt; expensiveTransaction::getValue","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_1_3/"},{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(4)","text":"Java 8 in action ç¬¬åç« ã€ç¬¬åä¸€ç« å­¦ä¹ ç¬”è®° Chapter 10. Using Optional as a better alternative to nullProblems with null (10.1.2) Itâ€™s a source of error. NullPointerException is by far the most common exception in Java. It bloats your code. It worsens readability by making it necessary to fill your code with often deeply nested null checks. Itâ€™s meaningless. It doesnâ€™t have any semantic meaning, and in particular it represents the wrong way to model the absence of a value in a statically typed language. It breaks Java philosophy. Java always hides pointers from developers except in one case: the null pointer. It creates a hole in the type system. null carries no type or other information, meaning it can be assigned to any reference type. This is a problem because, when itâ€™s propagated to another part of the system, you have no idea what that null was initially supposed to be. Using optionals in a domain model and why theyâ€™re not Serializable (10.3.3)Optional classåœ¨è®¾è®¡çš„æ—¶å€™æ²¡æœ‰è€ƒè™‘ç›´æ¥ç”¨åœ¨filed typeä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒçš„é¢„æƒ³ç”¨ä¾‹å¹¶ä¸æ˜¯ç›´æ¥å°†fieldsç›´æ¥å£°æ˜ä¸ºOptionalã€‚æ‰€ä»¥ï¼ŒOptionalæ²¡æœ‰å®ç°Serializableæ¥å£ï¼Œæ„å‘³ç€å¦‚æœæŸä¸ªclassåŒ…å«äº†Optional fieldï¼Œåºåˆ—åŒ–çš„è¿‡ç¨‹å°±ä¼šå¤±è´¥ã€‚ å¦‚æœä½ éœ€è¦è®©ä½ çš„modelèƒ½å¤Ÿè¢«åºåˆ—åŒ–ï¼Œä¸€ä¸ªå¯å–çš„æ–¹æ³•æ˜¯fieldsçš„å£°æ˜è¿˜æ˜¯ä¿æŒä¸å˜ï¼Œä½†æ˜¯åœ¨methodä¸Šè¿›è¡Œä¿®æ”¹ã€‚æ¯”å¦‚ä»¥ä¸‹çš„ä¾‹å­ï¼š 123456public class Person { private Car car; public Optional&lt;Car&gt; getCarAsOptional() { return Optional.ofNullable(car); }} å› ä¸ºPersonä¸ä¸€å®šéƒ½æ‹¥æœ‰Carï¼Œæ‰€ä»¥Caræ˜¯å­˜åœ¨ç¼ºå¤±çš„å¯èƒ½çš„ã€‚è¿™æ—¶æˆ‘ä»¬ä¸æ˜¯å°†Carå£°æ˜ä¸ºOptionalï¼Œè€Œæ˜¯åœ¨get methodé‡Œè¿”å›Optionalï¼ŒåŒæ—¶å…¼é¡¾äº†Optionalå’ŒSerializableã€‚getCarAsOptional()ä¹Ÿæé†’clientï¼ŒCaræ˜¯å¯èƒ½ç¼ºå¤±çš„è¿™ä¸€å±‚å«ä¹‰ã€‚ OrElseGetorElseGet(Supplier&lt;? extends T&gt; other) is the lazy counterpart of the orElse method, because the supplier is invoked only if the optional contains no value. You should use this method either when the default value is time-consuming to create (to gain a little efficiency) or you want to be sure this is done only if the optional is empty (in which case itâ€™s strictly necessary). Chapter 11. CompletableFuture: composable asynchronous programmingSynchronous vs. Asynchronous API (11.1.2) Synchronous APIYou call a method, the caller then waits while the method computes, the method then returns, and the caller continues with the returned value. Even if the caller and callee were executed on different threads, the caller would still wait for the callee to complete; this gives rise to the phrase blocking call. Asynchronous APIThe method returns immediately, or at least before its computation is complete, delegating its remaining computation to a thread, which runs asynchronously to the caller, hence the phrase non-blocking call. Implementing an asynchronous API (11.2)åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿé€šè¿‡serviceæä¾›çš„APIæ¥è·å–å¯¹åº”äº§å“çš„ä»·æ ¼ï¼Œæœ€ç»ˆè®¡ç®—å‡ºä»·æ ¼æœ€ä¾¿å®œçš„äº§å“çš„æƒ…æ™¯ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬ç»™å‡ºä¸€ä¸ªsynchronous APIçš„å®ç°ï¼š 1234567891011121314151617public double getPrice(String product) { return calculatePrice(product);}private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1);}// delayç”¨äºæ¨¡æ‹Ÿè¯·æ±‚APIåˆ°è·å¾—ç»“æœæ‰€èŠ±è´¹çš„æ—¶é—´public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); }} è¿™ä¸ªsynchronous APIçš„å®ç°æœ‰å¦‚ä¸‹å¼Šç«¯ï¼š When the consumer of this API (the best-price-finder application) invokes this method, it will remain blocked and then idle for 1 second while waiting for its synchronous completion. This is unacceptable, especially considering that the best-price-finder application will have to repeat this operation for all the shops in its network. å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦åšå‡ºä¸€äº›æ”¹è¿›ï¼Œå°†å…¶å®ç°ä¸ºasynchronous APIï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718public Future&lt;Double&gt; getPriceAsync(String product) { CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread ( () -&gt; { try { double price = calculatePrice(product); // Set the value returned by the long computation when it becomes available futurePrice.complete(price); } catch (Exception ex) { // Complete it exceptionally with the Exception caused the failure futurePrice.completeExceptionally(ex); } }).start(); // Return the Future without waiting for the computation of the result it contains return futurePrice;} å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯asynchronous taskä¹Ÿæ˜¯æœ‰å¯èƒ½å‡ºç°é”™è¯¯çš„ï¼Œè™½ç„¶æˆ‘ä»¬å¯ä»¥åœ¨è·å–Futureçš„ç»“æœæ—¶è®¾å®šä¸€ä¸ªtimeoutæ¥é¿å…æ— é™åœ°ç­‰å¾…ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•æœ€ç»ˆåªä¼šthrow TimeoutExceptionï¼Œå¯¹äºå®šä½çœŸæ­£é€ æˆfailureçš„åŸå› æ˜¯æ²¡æœ‰å¸®åŠ©çš„ã€‚å› æ­¤ï¼Œå°†Exceptionä¿å­˜åœ¨Futureé‡Œæ˜¯æ›´åˆç†çš„åšæ³•ã€‚ æœ€åï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡supplyAsync factory methodæ¥æ›´ç®€æ´åœ°å®ç°ä¸ä¸Šé¢çš„ä»£ç ç›¸åŒæ•ˆæœçš„ä»£ç ï¼ˆåŒ…æ‹¬è¿”å›çš„ç»“æœå’Œerror managementï¼‰ï¼š 123public Future&lt;Double&gt; getPriceAsync(String product) { return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));} Parallel and Asynchronous (11.3)é¦–å…ˆï¼Œæˆ‘ä»¬å‡å®šshopæä¾›çš„å•†å“ä»·æ ¼è·å–APIéƒ½æ˜¯synchronousçš„ï¼Œé‚£ä¹ˆä¸€ç§æ–¹å¼æ˜¯ä½¿ç”¨parallel streamï¼š 12345public List&lt;String&gt; findPrice(String product) { return shops.stream() .map(shop -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());} è¿˜æœ‰ä¸€ç§æ–¹å¼å°±æ˜¯ä½¿ç”¨å¼‚æ­¥è¯·æ±‚CompletableFutureï¼š 123456789101112131415161718public List&lt;String&gt; findPrice(String product) { List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product)) )) .collect(Collectors.toList()); /* * è¿™é‡Œåˆ†ä¸ºä¸¤ä¸ªstreamè¿›è¡Œå¤„ç†çš„åŸå› æ˜¯: * å¦‚æœåœ¨ç¬¬ä¸€ä¸ªstreamå¤„ç›´æ¥æ¥ä¸Šmap(CompletableFuture::join)ï¼Œ * ä¼šé€ æˆå‘shop1å‘é€getPriceçš„è¯·æ±‚å¹¶è¿”å›futureåï¼Œé©¬ä¸Šå°±è°ƒç”¨joinæŠŠå½“å‰threadé˜»å¡ï¼Œå»ç­‰å¾…shop1è¿”å›çš„ç»“æœã€‚ * å¯¼è‡´æ‰§è¡Œè¿‡ç¨‹å˜ä¸ºshop1.getprice() -&gt; join() -&gt; shop2.getprice() -&gt; join -&gt; ...ï¼Œ * æ²¡æœ‰çœŸæ­£åˆ©ç”¨åˆ°asyncçš„ç‰¹ç‚¹ã€‚ */ return priceFutures.stream() .map(CompletableFuture::join) .collect(Collectors.toList());} å½“shopçš„æ•°é‡ä¸º4ä¸”ä¸¤ä¸ªæ–¹æ³•åœ¨4æ ¸CPUä¸Šè¿è¡Œæ—¶ï¼Œparallelçš„æ–¹æ³•è€—æ—¶çº¦ä¸º1sï¼Œè€Œasyncæ–¹æ³•è€—æ—¶çº¦ä¸º2sã€‚è¿™é‡Œæ˜¯å› ä¸ºasyncéœ€è¦threadsä¹‹é—´çš„å¯¹CPUå’Œå†…å­˜çš„ç«äº‰ä»¥åŠä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚å¦‚æœå­˜åœ¨5ä¸ªshopï¼Œé‚£ä¹ˆparallelçš„æƒ…å†µä¸‹éœ€è¦è€—æ—¶çº¦2sï¼Œå› ä¸ºéœ€è¦ç­‰å¾…4ä¸ªå…ˆå‰çš„å¹¶è¡Œä»»åŠ¡ä¸­çš„æŸä¸ªå®Œæˆåæ‰èƒ½å‘èµ·æ–°çš„taskã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œasyncå¯ä»¥é€šè¿‡å®šä¹‰custom executorçš„æ–¹å¼æ¥scaleã€‚ 123456789101112131415161718192021private final Executor executor = Executors.newFixedThreadPool( // é˜²æ­¢shopsæ•°é‡è¿‡å¤šä½¿å¾—çº¿ç¨‹æ± å¯å…è®¸çš„threadsæ•°é‡å¤ªå¤š // threadsæ•°é‡å¤ªå¤šä¼šé€ æˆå¤§é‡å¯¹CPUå’Œå†…å­˜çš„ç«äº‰ä»¥åŠä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ Math.min(shops.size(), 100), new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); /* * A Java program canâ€™t terminate or exit while a normal thread is executing, * so a leftover thread waiting for a never-satisfiable event causes problems. * By contrast, marking a thread as a daemon means it can be killed on program termination. */ thread.setDaemon(true); return thread; } });// å°†custom executorç”¨äºfindPriceä¸­çš„CompletableFutureCompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product), executor); åœ¨ä½¿ç”¨custom executorçš„æƒ…å†µä¸‹ï¼Œasyncæ–¹æ³•ä¸­å¯ä»¥å‘èµ·çš„threadsæ•°é‡ä¸å†å±€é™äºCPUæ ¸å¿ƒæ•°ï¼Œå†åŠ ä¸ŠgetPriceä¸»è¦æ˜¯Network I/Oï¼Œå³ç­‰å¾…è¿œç«¯æœåŠ¡å™¨è®¡ç®—è¿”å›ç»“æœï¼Œthreadè‡ªèº«åªè´Ÿè´£å‘èµ·è¯·æ±‚ä½†æ²¡æœ‰å¯†é›†çš„è®¡ç®—ï¼Œå³ä½¿shopsæ•°é‡è¾¾åˆ°400ï¼Œä¹Ÿå¯ä»¥åœ¨çº¦ä¸º1så†…è·å¾—æ‰€æœ‰çš„pricesã€‚ å¯¹äºä½¿ç”¨parallelè¿˜æ˜¯asyncï¼Œä¸»è¦å–å†³äºtaskæ˜¯ä»¥computeä¸ºä¸»ï¼Œè¿˜æ˜¯ä»¥waitä¸ºä¸»ï¼š If youâ€™re doing computation-heavy operations with no I/O, then the Stream interface gives the simplest implementation and one likely to be the most efficient (if all threads are compute-bound, then thereâ€™s no point in having more threads than processor cores). On the other hand, if your parallel units of work involve waiting for I/O (including network connections), then CompletableFutures give more flexibility and the ability to match the number of threads to the wait/computer, or W/C, ratio. Combine independent asynchronous tasks (11.4)One frequently occurring case is where you need to combine the results of the operations performed by two completely independent CompletableFutures, and you donâ€™t want to wait for the first to complete before starting on the second. Turning to our running example, you may know that one of the shops provides prices in â‚¬(EUR), but you always want to communicate them in $ (USD) to your customers. You can asynchronously ask the shop the price of a given product and retrieve, from a remote exchange-rate service, the current exchange rate between â‚¬ and $. After both have completed, you can combine the results by multiplying the price by the exchange rate. The implementation could be: 1234567Future&lt;Double&gt; futurePriceInUSD = CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product)) .thenCombine( CompletableFuture.supplyAsync( () -&gt; exchangeService.getRate(Money.EUR, Money.USD)), (price, rate) -&gt; price * rate ); The workflow of combining these two asynchronous tasks should be: Reacting to a CompletableFuture completion (11.5)åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå‘ä¸åŒçš„shopè¯·æ±‚getPriceï¼Œå“åº”æ—¶é—´ä¹Ÿå„ä¸ç›¸åŒã€‚æœ‰æ—¶å€™æˆ‘ä»¬æƒ³è¦å®ç°ä¸€æ—¦ä»æŸä¸ªshopè·å–çš„priceè¢«è¿”å›ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç«‹åˆ»ä½¿ç”¨è¿™ä¸ªpriceï¼Œè€Œä¸éœ€è¦ç­‰å¾…æ‰€æœ‰taskséƒ½è¢«å®Œæˆåå†è¿›è¡Œä¸‹ä¸€æ­¥å¤„ç†ã€‚åœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨thenAcceptæ–¹æ³•ã€‚ 12345678910111213141516171819202122public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product) { return shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product), executor)) .map(future -&gt; future.thenApply(Quote::parse)) .map(future -&gt; future.thenCompose( quote -&gt; CompletableFuture.supplyAsync( () -&gt; Discount.applyDiscount(quote), executor)));}CompletableFuture[] futures = findPricesStream(&quot;myPhone&quot;) .map(f -&gt; f.thenAccept(System.out::println)) .toArray(size -&gt; new CompletableFuture[size]);/* * The allOf factory method * Input: an array of CompletableFutures * Return: CompletableFuture&lt;Void&gt; * thatâ€™s completed only when all the CompletableFutures passed have completed. * There is another method called anyOf() * it waits for the completion of only one of the CompletableFutures in an array. */CompletableFuture.allOf(futures).join(); thenAccept() operation simply registers an action on each CompletableFuture; this action consumes the value of the CompletableFuture as soon as it completes. It also has an Async variant schedules the execution of the Consumer passed to it on a new thread from the thread pool instead of directly performing it using the same thread that completed the CompletableFuture. Because the thenAccept method already specifies how to consume the result produced by the CompletableFuture when it becomes available, it returns a Completable-Future.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_10_11/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Optional","slug":"Optional","link":"/tags/Optional/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"}],"categories":[{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java 8 in action","slug":"è¯»ä¹¦ç¬”è®°/Java-8-in-action","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8-in-action/"}]}