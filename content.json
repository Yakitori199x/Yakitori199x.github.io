{"pages":[],"posts":[{"title":"Java 8 in action 学习笔记(4)","text":"Java 8 in action 第十章、第十一章学习笔记 Chapter 10. Using Optional as a better alternative to nullProblems with null (10.1.2) It’s a source of error. NullPointerException is by far the most common exception in Java. It bloats your code. It worsens readability by making it necessary to fill your code with often deeply nested null checks. It’s meaningless. It doesn’t have any semantic meaning, and in particular it represents the wrong way to model the absence of a value in a statically typed language. It breaks Java philosophy. Java always hides pointers from developers except in one case: the null pointer. It creates a hole in the type system. null carries no type or other information, meaning it can be assigned to any reference type. This is a problem because, when it’s propagated to another part of the system, you have no idea what that null was initially supposed to be. Using optionals in a domain model and why they’re not Serializable (10.3.3)Optional class在设计的时候没有考虑直接用在filed type上，也就是说，它的预想用例并不是直接将fields直接声明为Optional。所以，Optional没有实现Serializable接口，意味着如果某个class包含了Optional field，序列化的过程就会失败。 如果你需要让你的model能够被序列化，一个可取的方法是fields的声明还是保持不变，但是在method上进行修改。比如以下的例子： 123456public class Person { private Car car; public Optional&lt;Car&gt; getCarAsOptional() { return Optional.ofNullable(car); }} 因为Person不一定都拥有Car，所以Car是存在缺失的可能的。这时我们不是将Car声明为Optional，而是在get method里返回Optional，同时兼顾了Optional和Serializable。getCarAsOptional()也提醒client，Car是可能缺失的这一层含义。 OrElseGetorElseGet(Supplier&lt;? extends T&gt; other) is the lazy counterpart of the orElse method, because the supplier is invoked only if the optional contains no value. You should use this method either when the default value is time-consuming to create (to gain a little efficiency) or you want to be sure this is done only if the optional is empty (in which case it’s strictly necessary). Chapter 11. CompletableFuture: composable asynchronous programmingSynchronous vs. Asynchronous API (11.1.2) Synchronous APIYou call a method, the caller then waits while the method computes, the method then returns, and the caller continues with the returned value. Even if the caller and callee were executed on different threads, the caller would still wait for the callee to complete; this gives rise to the phrase blocking call. Asynchronous APIThe method returns immediately, or at least before its computation is complete, delegating its remaining computation to a thread, which runs asynchronously to the caller, hence the phrase non-blocking call. Implementing an asynchronous API (11.2)在这个例子中，我们模拟通过service提供的API来获取对应产品的价格，最终计算出价格最便宜的产品的情景。 首先，我们给出一个synchronous API的实现： 1234567891011121314151617public double getPrice(String product) { return calculatePrice(product);}private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1);}// delay用于模拟请求API到获得结果所花费的时间public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); }} 这个synchronous API的实现有如下弊端： When the consumer of this API (the best-price-finder application) invokes this method, it will remain blocked and then idle for 1 second while waiting for its synchronous completion. This is unacceptable, especially considering that the best-price-finder application will have to repeat this operation for all the shops in its network. 因此，我们需要做出一些改进，将其实现为asynchronous API，具体实现如下： 123456789101112131415161718public Future&lt;Double&gt; getPriceAsync(String product) { CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread ( () -&gt; { try { double price = calculatePrice(product); // Set the value returned by the long computation when it becomes available futurePrice.complete(price); } catch (Exception ex) { // Complete it exceptionally with the Exception caused the failure futurePrice.completeExceptionally(ex); } }).start(); // Return the Future without waiting for the computation of the result it contains return futurePrice;} 其中需要注意的是asynchronous task也是有可能出现错误的，虽然我们可以在获取Future的结果时设定一个timeout来避免无限地等待，但是这种方法最终只会throw TimeoutException，对于定位真正造成failure的原因是没有帮助的。因此，将Exception保存在Future里是更合理的做法。 最后，我们还可以通过supplyAsync factory method来更简洁地实现与上面的代码相同效果的代码（包括返回的结果和error management）： 123public Future&lt;Double&gt; getPriceAsync(String product) { return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));} Parallel and Asynchronous (11.3)首先，我们假定shop提供的商品价格获取API都是synchronous的，那么一种方式是使用parallel stream： 12345public List&lt;String&gt; findPrice(String product) { return shops.stream() .map(shop -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());} 还有一种方式就是使用异步请求CompletableFuture： 123456789101112131415161718public List&lt;String&gt; findPrice(String product) { List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product)) )) .collect(Collectors.toList()); /* * 这里分为两个stream进行处理的原因是: * 如果在第一个stream处直接接上map(CompletableFuture::join)， * 会造成向shop1发送getPrice的请求并返回future后，马上就调用join把当前thread阻塞，去等待shop1返回的结果。 * 导致执行过程变为shop1.getprice() -&gt; join() -&gt; shop2.getprice() -&gt; join -&gt; ...， * 没有真正利用到async的特点。 */ return priceFutures.stream() .map(CompletableFuture::join) .collect(Collectors.toList());} 当shop的数量为4且两个方法在4核CPU上运行时，parallel的方法耗时约为1s，而async方法耗时约为2s。这里是因为async需要threads之间的对CPU和内存的竞争以及上下文切换的开销。如果存在5个shop，那么parallel的情况下需要耗时约2s，因为需要等待4个先前的并行任务中的某个完成后才能发起新的task。相比之下，async可以通过定义custom executor的方式来scale。 123456789101112131415161718192021private final Executor executor = Executors.newFixedThreadPool( // 防止shops数量过多使得线程池可允许的threads数量太多 // threads数量太多会造成大量对CPU和内存的竞争以及上下文切换的开销 Math.min(shops.size(), 100), new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); /* * A Java program can’t terminate or exit while a normal thread is executing, * so a leftover thread waiting for a never-satisfiable event causes problems. * By contrast, marking a thread as a daemon means it can be killed on program termination. */ thread.setDaemon(true); return thread; } });// 将custom executor用于findPrice中的CompletableFutureCompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product), executor); 在使用custom executor的情况下，async方法中可以发起的threads数量不再局限于CPU核心数，再加上getPrice主要是Network I/O，即等待远端服务器计算返回结果，thread自身只负责发起请求但没有密集的计算，即使shops数量达到400，也可以在约为1s内获得所有的prices。 对于使用parallel还是async，主要取决于task是以compute为主，还是以wait为主： If you’re doing computation-heavy operations with no I/O, then the Stream interface gives the simplest implementation and one likely to be the most efficient (if all threads are compute-bound, then there’s no point in having more threads than processor cores). On the other hand, if your parallel units of work involve waiting for I/O (including network connections), then CompletableFutures give more flexibility and the ability to match the number of threads to the wait/computer, or W/C, ratio. Combine independent asynchronous tasks (11.4)One frequently occurring case is where you need to combine the results of the operations performed by two completely independent CompletableFutures, and you don’t want to wait for the first to complete before starting on the second. Turning to our running example, you may know that one of the shops provides prices in €(EUR), but you always want to communicate them in $ (USD) to your customers. You can asynchronously ask the shop the price of a given product and retrieve, from a remote exchange-rate service, the current exchange rate between € and $. After both have completed, you can combine the results by multiplying the price by the exchange rate. The implementation could be: 1234567Future&lt;Double&gt; futurePriceInUSD = CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product)) .thenCombine( CompletableFuture.supplyAsync( () -&gt; exchangeService.getRate(Money.EUR, Money.USD)), (price, rate) -&gt; price * rate ); The workflow of combining these two asynchronous tasks should be: Reacting to a CompletableFuture completion (11.5)在一般情况下，向不同的shop请求getPrice，响应时间也各不相同。有时候我们想要实现一旦从某个shop获取的price被返回，我们就可以立刻使用这个price，而不需要等待所有tasks都被完成后再进行下一步处理。在这种场景下，我们可以使用thenAccept方法。 12345678910111213141516171819202122public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product) { return shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product), executor)) .map(future -&gt; future.thenApply(Quote::parse)) .map(future -&gt; future.thenCompose( quote -&gt; CompletableFuture.supplyAsync( () -&gt; Discount.applyDiscount(quote), executor)));}CompletableFuture[] futures = findPricesStream(&quot;myPhone&quot;) .map(f -&gt; f.thenAccept(System.out::println)) .toArray(size -&gt; new CompletableFuture[size]);/* * The allOf factory method * Input: an array of CompletableFutures * Return: CompletableFuture&lt;Void&gt; * that’s completed only when all the CompletableFutures passed have completed. * There is another method called anyOf() * it waits for the completion of only one of the CompletableFutures in an array. */CompletableFuture.allOf(futures).join(); thenAccept() operation simply registers an action on each CompletableFuture; this action consumes the value of the CompletableFuture as soon as it completes. It also has an Async variant schedules the execution of the Consumer passed to it on a new thread from the thread pool instead of directly performing it using the same thread that completed the CompletableFuture. Because the thenAccept method already specifies how to consume the result produced by the CompletableFuture when it becomes available, it returns a Completable-Future.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_10_11/"},{"title":"Java 8 in action 学习笔记(1)","text":"Java 8 in action 第一章至第三章学习笔记 Chapter 1. Java 8: why should you care?Stream in Unix commands (1.1.2)Note that in Unix the commands (cat, tr, sort, and tail) are executed concurrently, so that sort can be processing the first few lines before cat or tr has finished. (P.s. 如同一个流水线一样，在Step1处理的同时，就将其已经生成的一部分结果输入到Step2去处理。） Optional (1.5)Optional includes methods to explicitly deal with the case where a value is absent, and as a result you can avoid NullPointer exceptions. Chapter 2. Passing code with behavior parameterizationBehavior parameterizationBehavior parameterization is a software development pattern that lets you handle frequent requirement changes. In a nutshell, it means taking a block of code and making it available without executing it. This block of code can be called later by other parts of your programs, which means that you can defer the execution of that block of code. For instance, you could pass the block of code as an argument to another method that will execute it later. As a result, the method’s behavior is parameterized based on that block of code. Behavior parameterization的发展（Java）- 以filterApples为例 如果想要以不同标准（颜色，重量…）来过滤🍎，最笨拙的方法是定义多个相似但带有不同判断逻辑的method，这样会使得代码非常冗余且难以维护。 作为改进，可以定义一个Predicate interface，然后定义多个不同的class去implement这个interface。filterApples method则可以接收Predicate的instance作为参数来实现behavior parameterization，behavior是通过被wrap在instance中来实现传递的。 但以上方法还是需要定义多个classes，其中很多可能仅仅使用了一次。为了减少verbosity，引入了anonymous class，允许程序员定义ad hoc classes。 不过anonymous class还是有一部分冗余的地方，比如每次都要声明父类和需要override的方法。lambda expression的出现进一步简化了这一问题，之后还衍生出更加简洁的method reference。 Chapter 3. Lambda expressionsLambda syntax (Quiz 3.1)123456789// Illegal, return is a control-flow statement.// It should be (Integer i) -&gt; {return &quot;Alan&quot; + i;}(Integer i) -&gt; return &quot;Alan&quot; + i;// Illegal, “Iron Man” is an expression, not a statement.// It should be (String s) -&gt; &quot;Iron Man&quot; or (String s) -&gt; {return &quot;Iron Man&quot;;}.(String s) -&gt; {&quot;Iron Man&quot;;}// p.s. 如果是statement，就算只有一句也要加上block Functional interfaces and Lambda expressions (3.2.1)Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline and treat the whole expression as an instance of a functional interface (more technically speaking, an instance of a concrete implementation of the functional interface). Execute around pattern (3.3)A recurrent pattern in resource processing (for example, dealing with files or databases) is to open a resource, do some processing on it, and then close the resource. The setup and cleanup phases are always similar and surround the important code doing the processing. This is called the execute around pattern. 1234567891011121314151617// execute around pattern很适合用lambda进行behavior parameterization// define functional interfacepublic interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException;}// define the method accept instance of the functional interfacepublic static String processFile (BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) { return p.process(br); }}// pass lambda expressionsString oneLine = processFile((BufferedReader br) -&gt; br.readLine());String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); Primitive specializations (3.4.3)Boxed values are essentially a wrapper around primitive types and are stored on the heap. Therefore, boxed values use more memory and require additional memory lookups to fetch the wrapped primitive value. Java 8 brings a specialized version of the functional interfaces in order to avoid autoboxing operations when the inputs or outputs are primitives. 1234567// no boxingIntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;evenNumbers.test(1000);// with boxingPredicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % 2 == 1;oddNumbers.test(1000) type-checking process (3.5.1)Use filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150); as an example. First, you look up the declaration of the filter method. (filter(List&lt;Apple&gt; inventory, Predicate&lt;Apple&gt; p)) Second, it expects as the second formal parameter an object of type Predicate&lt;Apple&gt; (the target type ). Third, Predicate is a functional interface defining a single abstract method called test. Fourth, the method test describes a function descriptor that accepts an Apple and returns a boolean. Finally, any actual argument to the filter method needs to match this requirement. Special void-compatibility ruleIf a lambda has a statement expression as its body, it’s compatible with a function descriptor that returns void (provided the parameter list is compatible too). For example, both of the following lines are legal even though the method add of a List returns a boolean and not void as expected in the Consumer context (T -&gt; void): 12345// Predicate has a boolean returnPredicate&lt;String&gt; p = s -&gt; list.add(s);// Consumer has a void returnConsumer&lt;String&gt; b = s -&gt; list.add(s); Recipe for constructing method references A method reference to a static method (Integer::parseInt) A method reference to an instance method of an arbitrary type (String::length) A method reference to an instance method of an existing object (expensiveTransaction::getValue, expensiveTransaction is an instance of type Transaction) 12345678910111213141. A method reference to a static methodLambda: (args) -&gt; ClassName.staticMethod(args) Method reference: ClassName::staticMethode.g. (String s) -&gt; Integer.parseInt(s) =&gt; Integer::parseInt2. A method reference to an instance method of an arbitrary typeLambda: (arg0, rest) -&gt; arg0.instanceMethod(rest) // arg0 is an instance of ClassNameMethod reference: ClassName::instanceMethode.g. (String s) -&gt; s.length() =&gt; String::length3. A method reference to an instance method of an existing objectLambda: (args) -&gt; expr.instanceMethod(args) // expr is an instance of some classMethod reference: expr::instanceMethode.g. () -&gt; expensiveTransaction.getValue() =&gt; expensiveTransaction::getValue","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_01_03/"},{"title":"Java 8 in action 学习笔记(2)","text":"Java 8 in action 第六章、第七章学习笔记 Chapter 6. Collecting data with streamsJoining Strings (6.2.3)The collector returned by the joining factory method concatenates into a single string all strings resulting from invoking the toString method on each object in the stream. 1String shortMenu = menu.stream().map(Dish::getName).collect(joining()); Note that joining internally makes use of a StringBuilder to append the generated strings into one. It also has an overloaded version that accepts a delimiter string between two consecutive elements. 123String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;));// Result:// pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon Collect vs. reduce123456789Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();List&lt;Integer&gt; numbers = stream.reduce( new ArrayList&lt;Integer&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; { l.add(e); return l; }, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; { l1.addAll(l2); return l1; }); The semantic problem: reduce method is meant to combine two values and produce a new one; it’s an immutable reduction. In contrast, the collect method is designed to mutate a container to accumulate the result it’s supposed to produce. The practical problem: this reduction process can’t work in parallel because the concurrent modification of the same data structure operated by multiple threads can corrupt the List itself. Multilevel grouping (6.3.1)You can achieve multilevel grouping by using a collector created with a two-argument version of the Collectors.groupingBy factory method, which accepts a second argument of type collector besides the usual classification function. 123456789101112131415161718192021public enum CaloricLevel { DIET, NORMAL, FAT };Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect( // outer collector with classification function groupingBy(Dish::getType, // inner collector groupingBy(dish -&gt; { if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }) ) )/* * Result will be like: * {MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]}, * FISH={DIET=[prawns], NORMAL=[salmon]}, * OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}} */ The regular one-argument groupingBy(f), where f is the classification function, is in reality just shorthand for groupingBy(f, toList()). More generally, the second collector passed to the first groupingBy can be any type of collector, not just another groupingBy. 123456789101112131415// count the number of Dishes in the menu for each type// {MEAT=3, FISH=2, OTHER=4}Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect( groupingBy(Dish::getType, counting()));// find the highest-calorie dish in the menu// {FISH=salmon, OTHER=pizza, MEAT=pork}// 因为maxBy返回的是Optional，此处需要用collectingAndThen将maxBy和Optional::get包起来// 其中，maxBy返回一个collector，Optional::get是transformation function，collectingAndThen也返回一个collector。Map&lt;Dish.Type, Dish&gt; mostCaloricType = menu.stream() .collect(groupingBy(Dish::getType, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get))); Chapter 7. Parallel data processing and performanceparallel() (7.1.1)In reality, calling the method parallel on a sequential stream doesn’t imply any concrete transformation on the stream itself. Internally, a boolean flag is set to signal that you want to run in parallel all the operations that follow the invocation to parallel. For the code: 123456stream.parallel() .filter(...) .sequential() .map(...) .parallel() .reduce(); Only the last call to parallel or sequential wins and affects the pipeline globally. Threads on multiple cores (7.1.2)Moving data between multiple cores is also more expensive than you might expect, so it’s important that work to be done in parallel on another core takes longer than the time required to transfer the data from one core to another. ForkJoinPool (7.2.1) Note that in a real-world application, it doesn’t make sense to use more than one ForkJoinPool. For this reason, what you typically should do is instantiate it only once and keep this instance in a static field, making it a singleton, so it could be conveniently reused by any part of your software. Invoking the join method on a task blocks the caller until the result produced by that task is ready. For this reason, it’s necessary to call it after the computation of both subtasks has been started. Calling the fork method on a subtask is the way to schedule it on the ForkJoinPool. It might seem natural to invoke it on both the left and right subtasks,** but this is less efficient than just directly calling compute on one of them.** Doing this allows you to reuse the same thread for one of the two subtasks and avoid the overhead caused by the unnecessary allocation of a further task on the pool. Work stealing (7.2.3)Ideally you want to partition the workload of a parallelized task in a way that each subtask takes exactly the same amount of time, keeping all the cores of your CPU equally busy. However, the time taken by each subtask can dramatically vary either due to the use of an inefficient partition strategy or because of unpredictable causes like slow access to the disk or the need to coordinate the execution with external services. The fork/join framework works around this problem with a technique called work stealing. Each of the threads holds a doubly linked queue of the tasks assigned to it, and as soon as it completes a task it pulls another one from the head of the queue and starts executing it. One thread might complete all the tasks assigned to it much faster than the others, in this case, instead of becoming idle, the thread randomly chooses a queue of a different thread and “steals” a task, taking it from the tail of the queue. It’s why having many smaller tasks, instead of only a few bigger ones, can help in better balancing the workload among the worker threads. More generally, this work-stealing algorithm is used to redistribute and balance the tasks among the worker threads in the pool.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_06_07/"},{"title":"Java 8 in action 学习笔记(3)","text":"Java 8 in action 第八章、第九章学习笔记 Chapter 8. Refactoring, testing, and debuggingAnonymous classes &amp; Lambda expressions (8.1.2) Inside an anonymous class, this refers to the anonymous class itself, but inside a lambda it refers to the enclosing class. Anonymous classes are allowed to shadow variables from the enclosing class. Lambda expressions can’t (they’ll cause a compile error). 123456789101112131415int a = 10;// LambdaRunnable r1 = () -&gt; { int a = 2; // Compile error System.out.println(a);};// Anonymous classRunnable r2 = new Runnable() { public void run() { int a = 2; // fine! System.out.println(a); }}; Converting an anonymous class to a lambda expression can make the resulting code ambiguous in the context of overloading. 1234567891011121314151617181920212223interface Task{ // execute() has the same signature as run() in Runnable public void execute();}// there are 2 overloaded methods inside a classpublic static void doSomething(Runnable r){ r.run(); }public static void doSomething(Task a){ r.execute(); }// Anonymous class// will call doSomething(Task)doSomething(new Task() { public void execute() { System.out.println(&quot;Danger danger!!&quot;); }});// Lambda// Both doSomething(Task) and doSomething(Runnable) matchdoSomething(() -&gt; System.out.println(&quot;Danger danger!!&quot;));// The ambiguity can be solved by explicit castdoSomething((Task)() -&gt; System.out.println(&quot;Danger danger!!&quot;)); Conditional deferred execution (8.1.5)1234567891011121314151617181920212223// Example 1// 1. The state of the logger (what level it supports) is exposed in the client code through the method isLoggable.// 2. Query the state of the logger object every time before you can log a message// 如果需要在多处进行log，就要将这个逻辑重复多次，相当繁琐if (logger.isLoggable(Log.FINER)){ logger.finer(&quot;Problem: &quot; + generateDiagnostic());}// Example 2// 这种写法使得需要log不同级别的日志时，只需要修改一下Level.xxx即可。// Unfortunately, there’s still an issue with this code. The logging message is always evaluated, even if the logger isn’t enabled for the message level passed as argument.logger.log(Level.FINER, &quot;Problem: &quot; + generateDiagnostic());// Example 3// lambda实现了当log level匹配时，log信息才会被生成。// 如果你发现代码中多次出现了判断某个instance的状态，仅为了进入condition去调用某些method的模式，就可以考虑引入一个新的method和lambda，将上述操作封装在新method里。public void log(Level level, Supplier&lt;String&gt; msgSupplier) { if (logger.isLoggable(level)){ log(level, msgSupplier.get()); }}logger.log(Level.FINER, () -&gt; &quot;Problem: &quot; + generateDiagnostic()); Design Pattern – Strategy (8.2.1)123456789101112131415161718192021// 通过functional interface + lambda可以快速定义多个strategy。// 同时，让client class调用interface中的abstract method。// 这样就可以通过传入不同的lambda来改变method的行为，从而实现在runtime确定究竟执行哪一套逻辑。public interface ValidationStrategy { boolean execute(String s);}public class Validator { private final ValidationStrategy strategy; public Validator (ValidationStrategy v) this.strategy = v; public boolean validate (String s) { return strategy.execute(s); }}Validator numericValidator = new Validator((String s) -&gt; s.matches(&quot;[0-9]+&quot;));boolean b1 = numericValidator.validate(&quot;aaaa&quot;); // return falseValidator lowerCaseValidator = new Validator((String s) -&gt; s.matches(&quot;\\\\d+&quot;));boolean b2 = lowerCaseValidator.validate(&quot;bbbb&quot;); // return true Chain of responsibility (8.2.4)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// One processing object may do some work and pass the result to another object, which then also does some work and passes it on to yet another processing object, and so on.// Generally, this pattern is implemented by defining an abstract class representing a processing object that defines a field to keep track of a successor. Once it has finished its work, the processing object hands over its work to its successor.// abstract class represents the processing objectpublic abstract class ProcessingObject&lt;T&gt; { // to track the successor object which will do further processing based on current result protected ProcessingObject&lt;T&gt; successor; public void setSuccessor(ProcessingObject&lt;T&gt; successor) { this.successor = successor; } public T handle(T input) { T r = handleWork(input); if (successor != null) { return successor.handle(r); } return r; } abstract protected T handleWork(T input);}public class HeaderTextProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return &quot;From Raoul, Mario and Alan: &quot; + text; }}public class SpellCheckerProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;); }}// Use in clientProcessingObject&lt;String&gt; p1 = new HeaderTextProcessing();ProcessingObject&lt;String&gt; p2 = new SpellCheckerProcessing();p1.setSuccessor(p2);String result1 = p1.handle(&quot;Aren't labdas really sexy?!!&quot;); // Result: From Raoul, Mario and Alan: Aren't lambda really sexy?!!// Turn to lambda implementationUnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);String result2 = pipeline.apply(&quot;Aren't labdas really sexy?!!&quot;); Chapter 9. Default methodsBinary Compatible (9.1.2)Adding a new method to an interface is binary compatible; this means existing class file implementations will still run without the implementation of the new method, if there’s no attempt to recompile them. If the user modify the code to use the new method (say setRelativeSize), an error will be thrown at run-time because the setRelativeSize method isn’t implemented: 12Exception in thread &quot;main&quot; java.lang.AbstractMethodError: lambdasinaction.chap9.Ellipse.setRelativeSize(II)V If the user tries to rebuild his entire application, he’ll get the following compile error: 1lambdasinaction/chap9/Ellipse.java:6: error: Ellipse is not abstract and does not override abstract method setRelativeSize(int,int) in Resizable Source compatibility &amp; Behavioral compatibility Source compatibility: source compatibility means an existing program will still compile after introducing a change.(e.g. adding a method to an interface isn’t source compatible) Behavioral compatibility: behavioral compatibility means running a program after a change with the same inputs results in the same behavior.(e.g. adding a method to an interface is behavioral compatible because the method is never called in the program) Resolution rules (9.4) Classes always win. A method declaration in the class or a superclass takes priority over any default method declaration. Otherwise, sub-interfaces win: the method with the same signature in the most specific default-providing interface is selected. (If B extends A, B is more specific than A). Finally, if the choice is still ambiguous, the class inheriting from multiple interfaces has to explicitly select which default method implementation to use by overriding it and calling the desired method explicitly. 12345678910111213141516171819202122232425262728293031323334// Example 1// A is an interface with method hello(), B is another interface extends A and override hello(), D is a class implements Apublic class D implements A {}public class C extends D implements B, A { public static void main (String[] args) { // hello() from B is called // Because D doesn’t override hello although it has a default method from interface A. And B is more specfic than A. new C().hello(); }}// Example 2public interface A { void hello() { System.out.println(&quot;Hello from A&quot;); }}public interface B { void hello() { System.out.println(&quot;Hello from B&quot;); }}// Error: class C inherits unrelated defaults for hello() from types B and A.public class C implements B, A { }// Solution: use X.super.m() where X is the superinterface whose method m you want to call.public class C implements B, A { void hello() { B.super.hello(); // explicitly choose to call hello() from B }}","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_08_09/"},{"title":"1. Course overview + the shell","text":"The Missing Semester of Your CS Education (2020): Lesson 1 1. Course overview + the shellMeanings of rwx of directory r 指的是能否浏览文件夹里的内容（to list its contents） w 指的是能否添加或删除文件夹里的内容（e.g. add/remove files in it），但还是可以修改文件夹中的某一文件的内容（在对该文件有权限的前提下） x 指的是能否进入该文件夹 To enter a directory, a user must have “search” (represented by “execute”: x) permissions on that directory (and its parents) Why sudo echo 500 &gt; brightness still causes permission denied? Operations like |, &gt;, and &lt; are done by the shell, not by the individual program. echo and friends do not “know” about |. They just read from their input and write to their output, whatever it may be. In the case above, the shell (which is authenticated just as your user) tries to open the brightness file for writing, before setting that as sudo echo’s output, but is prevented from doing so since the shell does not run as root. sudo echo 500 only gives current shell the root permission to execute echo command, but it still doesn’t have the permission for open&amp;write brightness. echo 1060 | sudo tee brightness Since the tee program is the one to open the /sys file for writing, and it is running as root, the permissions all work out. tee: takes its input and writes it to a file, but also to the stdout. It can be used when you want to send something into a file but also want to see it to yourself. xdg-open 使用 xdg-open 打开文件时，会自动使用最合适的程序去打开这个文件。比如 xdg-open xxx.html 会用浏览器打开这个html文件，相当于我们用双击鼠标打开文件的效果。 Shell The shell is a programming environment, just like Python or Ruby, and so it has variables, conditionals, loops, and functions. When we run the echo command, the shell sees that it should execute the program echo, and then searches through the :-separated list of directories in $PATH for a file by that name. When it finds it, it runs it (assuming the file is executable). Run the command by explicitly starting the sh interpreter, and giving it the file semester as the first argument, i.e. sh semester.","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/1_Course%20overview_+_the_shell/"},{"title":"2. Shell Tools and Scripting","text":"The Missing Semester of Your CS Education (2020): Lesson 2 2. Shell Tools and ScriptingA seris of special variables $0 - Name of the script $1 to $9 - Arguments to the script. $1 is the first argument and so on $@ - All the arguments $# - Number of arguments $? - Return code of the previous command (A value of 0 usually means everything went OK; anything different from 0 means an error occurred.) $$ - Process identification number (PID) for the current script 12345678910111213141516171819#!/bin/bash# Command substitution: date will be substitute# Use $(command) to refer to the output of the comanndecho &quot;Starting program at $(date)&quot;echo &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null/ 2&gt; /dev/null # Redirect STDOUT and STDERR to a null register # When pattern is not found, grep has exit status 1 # When performing comparisons in bash, try to use double brackets [[ ]] in favor of simple brackets [ ]. if [[ &quot;$?&quot; -ne 0 ]]; then echo &quot;File $file doesn't have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone !! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing sudo !! $_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . Process substitution cat &lt;(ls) &lt;(ls ..) : &lt;( CMD ) will execute CMD and place the output in a temporary file and substitute the &lt;() with that file’s name. This example will print the list of contents in current dir and its parent dir. Shebang (#!) #!/usr/local/bin/python : The kernel knows to execute this script with a python interpreter instead of a shell command because we included a shebang line at the top of the script. #!/usr/bin/env python : Tell the kernel to run this script with env command. env will make use of the PATH environment variable to find python interpreter to execute this script, which increases the portability of your scripts. (Because python is not necessarily in /usr/local/bin/python) 4. TLDR Sometimes manpages can provide overly detailed descriptions of the commands, making it hard to decipher what flags/syntax to use for common use cases. TLDR pages are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use. CTRL + R In most shells, you can make use of Ctrl+R to perform backwards search through your history. After pressing Ctrl+R, you can type a substring you want to match for commands in your history. As you keep pressing it, you will cycle through the matches in your history. ExerciseQ1 Includes all files, including hidden files (ls -a) Sizes are listed in human readable format (e.g. 454M instead of 454279954) (ls -lh, -h means human-readable) Files are ordered by recency (ls -lt, -t means sort by modification time) Output is colorized (ls –color=auto) 12345678910111213[ngsuser@testenv101 /]$ ls -ltha --color=autototal 1.1Gdrwxr-xr-x. 30 root root 1000 Sep 13 07:41 rundrwxrwxrwt. 12 root root 4.0K Sep 12 13:16 tmpdrwxr-xr-x. 95 root root 8.0K Sep 11 14:18 etcdrwxr-xr-x. 5 ngsuser ngsgroup 107 Sep 11 03:37 data2drwxr-xr-x. 15 root root 178 Jul 16 09:54 usrdrwxr-xr-x. 5 root root 71 Jul 16 09:52 optdr-xr-xr-x. 178 root root 0 Jul 16 09:49 procdrwxr-xr-x. 20 root root 3.0K Jul 16 09:49 devdr-xr-xr-x. 13 root root 0 Jul 16 09:49 sysdrwxr-xr-x. 1 vagrant vagrant 288 Jul 16 09:39 vagrant... Q2 marco.sh 12345#!/bin/bashmarco() { export CUR_DIR=&quot;$(pwd)&quot;} polo.sh 12345#!/bin/bashpolo() { cd &quot;$CUR_DIR&quot;} Result 1234567891011[ngsuser@testenv101 ngsuser]$ pwd/home/ngsuser[ngsuser@testenv101 ngsuser]$ source marco.sh[ngsuser@testenv101 ngsuser]$ source polo.sh[ngsuser@testenv101 ngsuser]$ marco[ngsuser@testenv101 ngsuser]$ cd /[ngsuser@testenv101 /]$ pwd/[ngsuser@testenv101 /]$ polo[ngsuser@testenv101 ngsuser]$ pwd/home/ngsuser Q31234567891011#!/usr/bin/env bashfile=&quot;test_script.sh&quot;while [[ &quot;$?&quot; -ne 1 ]]; do ./$file 1&gt;&gt; run.log 2&gt;&gt; debug.logdoneecho &quot;$file runs $(cat run.log | wc -l) times&quot;&gt; run.log&gt; debug.log Q4123456789101112131415161718# When piping commands, we are connecting STDOUT to STDIN, but some commands like tar take inputs from arguments. # To bridge this disconnect there’s the xargs command which will execute a command using STDIN as arguments.# Recursively find all the markdown files# xargs will pass STDIN arguments to tar command# Because some files contain space in their names, we need to configure -d of xargs with &quot;\\n&quot;, means using &quot;\\n&quot; as delimiter[ngsuser@testenv101 missing-semester]$ find . -name &quot;*.md&quot; | xargs -d &quot;\\n&quot; tar -czf gzippack.tar.gz[ngsuser@testenv101 missing-semester]$ tar -xzf gzippack.tar.gz -C extract[ngsuser@testenv101 missing-semester]$ ls -R extract/extract/:_2019 _2020 about.md index.md license.md md with space.md README.mdextract/_2019:automation.md command-line.md data-wrangling.md editors.md os-customization.md program-introspection.md security.md version-control.md web.mdbackups.md course-overview.md dotfiles.md machine-introspection.md package-management.md remote-machines.md shell.md virtual-machines.mdextract/_2020:command-line.md course-shell.md data-wrangling.md debugging-profiling.md editors.md metaprogramming.md potpourri.md qa.md security.md shell-tools.md version-control.md Q512345# find all the files under current directory recursively# use xargs to pass files as arguments to ls command# head command gets the first record[ngsuser@testenv101 missing-semester]$ find . -type f | xargs -d &quot;\\n&quot; ls -lt | head -n 1-rw-r--r--. 1 ngsuser ngsgroup 288484 Sep 16 12:14 ./gzippack.tar.gz","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/2_Shell_Tools_and_Scripting/"},{"title":"4 Data Wrangling","text":"The Missing Semester of Your CS Education (2020): Lesson 4 4 Data WranglingSSHssh can send command to remote server and stream the result to local 12# use a pipe to stream a remote file through grep on our local computerssh myserver journalctl | grep sshd seds command: s/REGEX/SUBSTITUTION/. REGEX is the regular expression you want to search for, and SUBSTITUTION is the text you want to substitute matching text with. 12345# substitute the part end with &quot;Disconnected from &quot; in each line with emptyssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed 's/.*Disconnected from //' Regular expressions . means “any single character” except newline * zero or more of the preceding match + one or more of the preceding match [abc] any one character of a, b, and c (RX1|RX2) either something that matches RX1 or RX2 ^ the start of the line $ the end of the line * and + are, by default, “greedy”. They will match as much text as they can. Suffix them with a ? to make them non-greedy in some implementations. (not sed) 123# If someone tried to log in with the username “Disconnected from”Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]-&gt; 46.97.239.16 port 55920 [preauth] -&gt; user name lost () : capture groups 123# Because sed doesn't support ? to turn to non-greedy, we have to match the whole line# Substitute the matched str by the second capture group (\\2), which is (.*)... | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' awk The default pattern (which we used above) matches all lines. $0 is set to the entire line’s contents, and $1 through $n are set to the nth field of that line. Field separator (whitespace by default, change with -F) 12# here, for every line, print the contents of the second field... | awk '{print $2}' The pattern says that the first field of the line should be equal to 1, and that the second field should match the given regular expression. 12# Compute the number of single-use usernames that start with c and end with e... | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l BEGIN is a pattern that matches the start of the input (and END matches the end). 12345# Now, the per-line block just adds the count from the first field,# and then we print it out at the end.BEGIN { rows = 0 }$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }END { print rows } ExerciseQ1.1: Matching a decimal numbers12345678910Match 3.14529Match -255.34Match 128Match 1.9e10Match 123,340.00Skip 720pSolution: ^-?\\d+(,\\d+)*(\\.\\d+(e\\d+)?)?$P.s. (e\\d+)?需要包含在(\\.\\d+...)?里面，是因为如果出现科学计数法，e之前必定有小数点。 如果不包含起来，19e10这样的也会被匹配到。 Q1.2: Matching phone numbers123456789Capture 415-555-1234 415Capture 650-555-2345 650Capture (416)555-3456 416Capture 202 555 4567 202Capture 4035555678 403Capture 1 416 555 9292 416Solution: 1?[\\s-]?\\(?(\\d{3})\\)?[\\s-]?\\d{3}[\\s-]?\\d{4}思路: 先用1?[\\s-]?处理country code，之后就按照正常的3，3，4的结构去处理。 Q1.3: Matching emails123456789Capture tom@hogwarts.com tomCapture tom.riddle@hogwarts.com tom.riddleCapture tom.riddle+regexone@hogwarts.com tom.riddleCapture tom@hogwarts.eu.com tomCapture potter@hogwarts.com potterCapture harry@hogwarts.com harryCapture hermione+regexone@hogwarts.comSolution: ^([\\w\\.]*) Q1.4: Capturing HTML Tags123456Capture &lt;a&gt;This is a link&lt;/a&gt; aCapture &lt;a href='https://regexone.com'&gt;Link&lt;/a&gt; aCapture &lt;div class='test_style'&gt;Test&lt;/div&gt; divCapture &lt;div&gt;Hello &lt;span&gt;world&lt;/span&gt;&lt;/div&gt; divSolution: &lt;(\\w+) Q1.5: Capturing Filename Data12345678910Skip .bash_profileSkip workspace.docCapture img0912.jpg img0912 jpgCapture updated_img0912.png updated_img0912 pngSkip documentation.htmlCapture favicon.gif favicon gifSkip img0912.jpg.tmpSkip access.lockSolution: (\\w+)\\.(jpg|png|gif)$ Q1.6: Trimming whitespace from start and end of line1234Capture The quick brown fox... The quick brown fox... Capture jumps over the lazy dog. jumps over the lazy dog.Solution: ^\\s*(.*)\\s*$ Q1.7: Extracting Data From Log Entries12345678Skip W/dalvikvm( 1553): threadid=1: uncaught exceptionSkip E/( 1553): FATAL EXCEPTION: mainSkip E/( 1553): java.lang.StringIndexOutOfBoundsExceptionCapture E/( 1553): at widget.List.makeView(ListView.java:1727) makeView ListView.java 1727Capture E/( 1553): at widget.List.fillDown(ListView.java:652) fillDown ListView.java 652Capture E/( 1553): at widget.List.fillFrom(ListView.java:709) fillFrom ListView.java 709Solution: (\\w+)\\(([\\w\\.]+):(\\d+)\\) Q1.8: Extracting Data From URLs1234567Capture ftp://file_server.com:21/top_secret/life_changing_plans.pdf ftp file_server.com 21Capture https://regexone.com/lesson/introduction#section https regexone.comCapture file://localhost:4040/zip_file file localhost 4040Capture https://s3cur3-server.com:9999/ https s3cur3-server.com 9999Capture market://search/angry%20birds market searchSolution: (\\w+)://([\\w\\-\\.]+):?(\\d+)? Q2 What are the three most common last two letters of those words? 123456# 先找出包含三个以上a的字符串，然后再grep -v逆向match以's结尾的字符串# 接着使用sed获取最后两个字符，最后就是sort，去重并统计数量，按第一列逆向排序，取头3个即可cat words | grep '.*[aA].*[aA].*[aA]' | grep -v &quot;.*'s$&quot; | sed -E 's/.*(.{2})$/\\1/' | sort | uniq -c | sort -rk1 |head -n31039 al 814 ia 763 an How many of those two-letter combinations are there? 12cat words | grep '.*[aA].*[aA].*[aA]' | grep -v &quot;.*'s$&quot; | sed -E 's/.*(.{2})$/\\1/' | sort | uniq -c | wc -l156 Q3 为什么 sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt 这样的做法不好？因为 &gt; 会先把目标文件清空，然后读取执行command后产生的输出并写入目标文件。在这个情况下，input.txt被清空后就没办法正确匹配到内容，最后input.txt会变成空的。可以写入其他的文件或是使用 -i 选项。","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/4_Data_Wrangling/"},{"title":"5. Command Line Environment","text":"The Missing Semester of Your CS Education (2020): Lesson 5 5. Command Line EnvironmentJob Control1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# Ctrl-Z -&gt; SIGSTOP, stop or pause current process$ sleep 1000^Z[1] + 18653 suspended sleep 1000# launch process with nohup (a wrapper to ignore SIGHUP)$ nohup sleep 2000 &amp;[2] 18745appending output to nohup.out# list the unfinished jobs associated with the current terminal session$ jobs[1] + suspended sleep 1000[2] - running nohup sleep 2000# continue the paused job in the foreground or in the background using fg or bg# refer to a process using the percent symbol followed by its job number (displayed by jobs)# $!: the last backgrounded job$ bg %1[1] - 18653 continued sleep 1000$ jobs[1] - running sleep 1000[2] + running nohup sleep 2000# you can also send SIGSTOP signal with kill command$ kill -STOP %1[1] + 18653 suspended (signal) sleep 1000$ jobs[1] + suspended (signal) sleep 1000[2] - running nohup sleep 2000# because %1 cannot handle SIGHUP, it will be stopped/killed$ kill -SIGHUP %1[1] + 18653 hangup sleep 1000$ jobs[2] + running nohup sleep 2000$ kill -SIGHUP %2# %2 ignores SIGHUP, it will keep running$ jobs[2] + running nohup sleep 2000$ kill %2[2] + 18745 terminated nohup sleep 2000$ jobs &amp; : &amp; suffix in a command will run the command in the background, giving you the prompt back Backgrounded processes are still children processes of your terminal and will die if you close the terminal (this will send yet another signal, SIGHUP). pgrep: find out pid of jobs Terminal Multiplexers (tmux) tmux has keybindings with the form &lt;C-b&gt; + x (prefix key followed by a command key): (1) press Ctrl+b, (2) release Ctrl+b, and then (3) press x. (Ctrl+b can be rebinding to other key like Ctrl+a) Sessions 12345tmux: starts a new session.tmux new -s NAME: starts it with that name.tmux ls: lists the current sessionsWithin tmux typing &lt;C-b&gt; d: detaches the current sessiontmux a: attaches the last session. You can use -t flag to specify which Windows 123456&lt;C-b&gt; c: Creates a new window. To close it you can just terminate the shells doing &lt;C-d&gt;&lt;C-b&gt; N: Go to the N th window. Note they are numbered&lt;C-b&gt; p: Goes to the previous window&lt;C-b&gt; n: Goes to the next window&lt;C-b&gt; ,: Rename the current window&lt;C-b&gt; w: List current windows Panes 123456&lt;C-b&gt; &quot;: Split the current pane horizontally&lt;C-b&gt; %: Split the current pane vertically&lt;C-b&gt; &lt;direction&gt;: Move to the pane in the specified direction. Direction here means arrow keys.&lt;C-b&gt; z: Toggle zoom for the current pane&lt;C-b&gt; [: Start scrollback. You can then press &lt;space&gt; to start a selection and &lt;enter&gt; to copy that selection.&lt;C-b&gt; &lt;space&gt;: Cycle through pane arrangements. (自动切换不同的排列) Dotfiles Portability1234567if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi# Check before using shell-specific featuresif [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi# You can also make it machine-specificif [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi ExerciseQ1123456sleep 10000C-zbg %1# -a: list PID and full command linepgrep -af sleeppkill sleep Q21234567# wait only works for child processes# 注意不能使用pipe(|)，因为pipe会开启一个新的subshell(bash)去执行指令。# 就会导致sleep 60 &amp;是当前shell的child process而wait $! | ls是subshell的child process。[ngsuser@testenv101 ~]$ sleep 60 &amp; wait $! ; ls[1] 24522[1]+ Done sleep 60bin data dev_docs etc GSP-VERSION missing-semester nohup.out schema service-conf-packaged test-data tmux.py usr var VERSION","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/5_Command_Line_Environment/"},{"title":"Core Java Volume I 学习笔记(1)","text":"Core Java Volume I 第七章至第九章学习笔记 Chapter 7: Exceptions, Assertions, and Loggingchecked exception和unchecked exception？assertion和exception的不同？使用场景？Chapter 8: Generic ProgrammingBridge method （8.5.3 Translating Generic Methods）首先我们来分析ordinary class的多态。假设我们有定义了一个 DateInterval class去继承 Pair class。在 Pair 中存在一个 public void setSecond(Object second)，而我们在 DateInterval 中定义了 public void setSecond(LocalDate second)。这种情况不是override而是overload。 1234567891011class Pair{ public void setSecond(Object second) { . . . } . . .}class DateInterval extends Pair{ public void setSecond(LocalDate second) { . . . } . . .} 也就是说，如果我们执行以下代码，最终在runtime被执行的也是从 Pair 继承下来的 publicvoid setSecond(Object second)。 1234DateInterval interval = new DateInterval(. . .);Pair pair = interval;// setSecond(Object second) but not setSecond(LocalDate second)pair.setSecond(aDate); 接下来我们把情况扩展到generics的范畴，即存在一个generic class Pair&lt;T&gt;, DateInterval 继承了 Pair&lt;LocalDate&gt;： 12345678910class DateInterval extends Pair&lt;LocalDate&gt;{ // override setSecond(LocalDate second) in Pair&lt;LocalDate&gt; (fromprogrammer's view) public void setSecond(LocalDate second) { if (second.compareTo(getFirst()) &gt;= 0) super.setSecond(second); } . . .} 但是，由于complier最终会把 type variable 给erasure了，上述代码实际上是： 123456789class DateInterval extends Pair // after erasure{ // inherit from Pair public void setSecond(Object second) { . . . } // overload public void setSecond(LocalDate second) { . . . } . . .} 在这种情况下，如果执行以下代码，根据Java多态的规则，被调用的应该是继承下来的void setSecond(Object second)： 123DateInterval interval = new DateInterval(. . .);Pair&lt;LocalDate&gt; pair = interval; // OK--assignment to superclasspair.setSecond(aDate); // void setSecond(Object second) is called 很明显这个结果不是我们所期望的，type erasure 影响了多态。为了修复这一问题，complier会在 DateInterval 自动生成 bridge method： 12// call the defined setSecond(LocalDate second) through setSecond(Object second)public void setSecond(Object second) { setSecond((Date) second); } 这样一来，即使进行了类型擦除，最终也能够调用到我们定义的，我们认为是进行了override的那个method。 What is Wildcards in Java Generics for? (8.8 Wildcard Types) Generic classes之间本身不存在relation，但是wildcard可以与与它们产生subtype或者supertype的relation。详见：Java Generic’s Wildcards - Jenkov Tutorials Wildcard type instantiation example (8.8 Wildcard Types)1234567891011121314151617181920212223public class Pair&lt;T&gt; { private T first; private T second; public Pair(T first, T second) { this.first = first; this.second = second; } public T getFirst() { return first; } public T getSecond() { return second; } public static void main(String[] args) { // legal, 说明wildcard在初始化时并不会要求传入的first和second类型一致。 Pair&lt;?&gt; pair = new Pair&lt;&gt;(1, &quot;happy&quot;); }} Chapter 9: Collectionsoff-by-one error比如在循环的时候多循环了一次或是少循环了一次导致error，这类型的error就是off-by-one error。 References: What is an off-by-one error and how do I fix it? - Answered by Mark Byers Off-by-one error - Wikipedia","link":"/2021/01/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Core_Java_Volume_I:_Fundamentals%20_10th_Edition/Core_Java_Volume_I_Chapter_07_09/"},{"title":"好文收藏","text":"收藏一些看过的优秀文章，优秀回答 好文收藏Backpressure 如何形象的描述反应式编程中的背压(Backpressure)机制？– 扔物线的回答 Horizontal&amp;Vertical Scaling Difference between scaling horizontally and vertically for databases Unit test | Integration tests | Smoke tests | Regression tests What are unit tests, integration tests, smoke tests, and regression tests? Kerberos 能用通用的语言介绍下 Kerberos 协议么？– 车小胖的回答","link":"/2021/01/06/%E5%A5%BD%E6%96%87%E6%94%B6%E8%97%8F/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Optional","slug":"Optional","link":"/tags/Optional/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Regex","slug":"Regex","link":"/tags/Regex/"},{"name":"Job control","slug":"Job-control","link":"/tags/Job-control/"},{"name":"Tmux","slug":"Tmux","link":"/tags/Tmux/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"Generic Programming","slug":"Generic-Programming","link":"/tags/Generic-Programming/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"},{"name":"精选文章","slug":"精选文章","link":"/tags/%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java 8 in action","slug":"读书笔记/Java-8-in-action","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8-in-action/"},{"name":"课程笔记","slug":"课程笔记","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"The Missing Semester of Your CS Education (2020)","slug":"课程笔记/The-Missing-Semester-of-Your-CS-Education-2020","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The-Missing-Semester-of-Your-CS-Education-2020/"},{"name":"Core Java Volume I","slug":"读书笔记/Core-Java-Volume-I","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Core-Java-Volume-I/"},{"name":"精选文章汇总","slug":"精选文章汇总","link":"/categories/%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"}]}