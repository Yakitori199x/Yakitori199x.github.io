{"pages":[],"posts":[{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(4)","text":"Java 8 in action ç¬¬åç« ã€ç¬¬åä¸€ç« å­¦ä¹ ç¬”è®° Chapter 10. Using Optional as a better alternative to nullProblems with null (10.1.2) Itâ€™s a source of error. NullPointerException is by far the most common exception in Java. It bloats your code. It worsens readability by making it necessary to fill your code with often deeply nested null checks. Itâ€™s meaningless. It doesnâ€™t have any semantic meaning, and in particular it represents the wrong way to model the absence of a value in a statically typed language. It breaks Java philosophy. Java always hides pointers from developers except in one case: the null pointer. It creates a hole in the type system. null carries no type or other information, meaning it can be assigned to any reference type. This is a problem because, when itâ€™s propagated to another part of the system, you have no idea what that null was initially supposed to be. Using optionals in a domain model and why theyâ€™re not Serializable (10.3.3)Optional classåœ¨è®¾è®¡çš„æ—¶å€™æ²¡æœ‰è€ƒè™‘ç›´æ¥ç”¨åœ¨filed typeä¸Šï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒçš„é¢„æƒ³ç”¨ä¾‹å¹¶ä¸æ˜¯ç›´æ¥å°†fieldsç›´æ¥å£°æ˜ä¸ºOptionalã€‚æ‰€ä»¥ï¼ŒOptionalæ²¡æœ‰å®ç°Serializableæ¥å£ï¼Œæ„å‘³ç€å¦‚æœæŸä¸ªclassåŒ…å«äº†Optional fieldï¼Œåºåˆ—åŒ–çš„è¿‡ç¨‹å°±ä¼šå¤±è´¥ã€‚ å¦‚æœä½ éœ€è¦è®©ä½ çš„modelèƒ½å¤Ÿè¢«åºåˆ—åŒ–ï¼Œä¸€ä¸ªå¯å–çš„æ–¹æ³•æ˜¯fieldsçš„å£°æ˜è¿˜æ˜¯ä¿æŒä¸å˜ï¼Œä½†æ˜¯åœ¨methodä¸Šè¿›è¡Œä¿®æ”¹ã€‚æ¯”å¦‚ä»¥ä¸‹çš„ä¾‹å­ï¼š 123456public class Person { private Car car; public Optional&lt;Car&gt; getCarAsOptional() { return Optional.ofNullable(car); }} å› ä¸ºPersonä¸ä¸€å®šéƒ½æ‹¥æœ‰Carï¼Œæ‰€ä»¥Caræ˜¯å­˜åœ¨ç¼ºå¤±çš„å¯èƒ½çš„ã€‚è¿™æ—¶æˆ‘ä»¬ä¸æ˜¯å°†Carå£°æ˜ä¸ºOptionalï¼Œè€Œæ˜¯åœ¨get methodé‡Œè¿”å›Optionalï¼ŒåŒæ—¶å…¼é¡¾äº†Optionalå’ŒSerializableã€‚getCarAsOptional()ä¹Ÿæé†’clientï¼ŒCaræ˜¯å¯èƒ½ç¼ºå¤±çš„è¿™ä¸€å±‚å«ä¹‰ã€‚ OrElseGetorElseGet(Supplier&lt;? extends T&gt; other) is the lazy counterpart of the orElse method, because the supplier is invoked only if the optional contains no value. You should use this method either when the default value is time-consuming to create (to gain a little efficiency) or you want to be sure this is done only if the optional is empty (in which case itâ€™s strictly necessary). Chapter 11. CompletableFuture: composable asynchronous programmingSynchronous vs. Asynchronous API (11.1.2) Synchronous APIYou call a method, the caller then waits while the method computes, the method then returns, and the caller continues with the returned value. Even if the caller and callee were executed on different threads, the caller would still wait for the callee to complete; this gives rise to the phrase blocking call. Asynchronous APIThe method returns immediately, or at least before its computation is complete, delegating its remaining computation to a thread, which runs asynchronously to the caller, hence the phrase non-blocking call. Implementing an asynchronous API (11.2)åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿé€šè¿‡serviceæä¾›çš„APIæ¥è·å–å¯¹åº”äº§å“çš„ä»·æ ¼ï¼Œæœ€ç»ˆè®¡ç®—å‡ºä»·æ ¼æœ€ä¾¿å®œçš„äº§å“çš„æƒ…æ™¯ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬ç»™å‡ºä¸€ä¸ªsynchronous APIçš„å®ç°ï¼š 1234567891011121314151617public double getPrice(String product) { return calculatePrice(product);}private double calculatePrice(String product) { delay(); return random.nextDouble() * product.charAt(0) + product.charAt(1);}// delayç”¨äºæ¨¡æ‹Ÿè¯·æ±‚APIåˆ°è·å¾—ç»“æœæ‰€èŠ±è´¹çš„æ—¶é—´public static void delay() { try { Thread.sleep(1000L); } catch (InterruptedException e) { throw new RuntimeException(e); }} è¿™ä¸ªsynchronous APIçš„å®ç°æœ‰å¦‚ä¸‹å¼Šç«¯ï¼š When the consumer of this API (the best-price-finder application) invokes this method, it will remain blocked and then idle for 1 second while waiting for its synchronous completion. This is unacceptable, especially considering that the best-price-finder application will have to repeat this operation for all the shops in its network. å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦åšå‡ºä¸€äº›æ”¹è¿›ï¼Œå°†å…¶å®ç°ä¸ºasynchronous APIï¼Œå…·ä½“å®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718public Future&lt;Double&gt; getPriceAsync(String product) { CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;(); new Thread ( () -&gt; { try { double price = calculatePrice(product); // Set the value returned by the long computation when it becomes available futurePrice.complete(price); } catch (Exception ex) { // Complete it exceptionally with the Exception caused the failure futurePrice.completeExceptionally(ex); } }).start(); // Return the Future without waiting for the computation of the result it contains return futurePrice;} å…¶ä¸­éœ€è¦æ³¨æ„çš„æ˜¯asynchronous taskä¹Ÿæ˜¯æœ‰å¯èƒ½å‡ºç°é”™è¯¯çš„ï¼Œè™½ç„¶æˆ‘ä»¬å¯ä»¥åœ¨è·å–Futureçš„ç»“æœæ—¶è®¾å®šä¸€ä¸ªtimeoutæ¥é¿å…æ— é™åœ°ç­‰å¾…ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•æœ€ç»ˆåªä¼šthrow TimeoutExceptionï¼Œå¯¹äºå®šä½çœŸæ­£é€ æˆfailureçš„åŸå› æ˜¯æ²¡æœ‰å¸®åŠ©çš„ã€‚å› æ­¤ï¼Œå°†Exceptionä¿å­˜åœ¨Futureé‡Œæ˜¯æ›´åˆç†çš„åšæ³•ã€‚ æœ€åï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡supplyAsync factory methodæ¥æ›´ç®€æ´åœ°å®ç°ä¸ä¸Šé¢çš„ä»£ç ç›¸åŒæ•ˆæœçš„ä»£ç ï¼ˆåŒ…æ‹¬è¿”å›çš„ç»“æœå’Œerror managementï¼‰ï¼š 123public Future&lt;Double&gt; getPriceAsync(String product) { return CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));} Parallel and Asynchronous (11.3)é¦–å…ˆï¼Œæˆ‘ä»¬å‡å®šshopæä¾›çš„å•†å“ä»·æ ¼è·å–APIéƒ½æ˜¯synchronousçš„ï¼Œé‚£ä¹ˆä¸€ç§æ–¹å¼æ˜¯ä½¿ç”¨parallel streamï¼š 12345public List&lt;String&gt; findPrice(String product) { return shops.stream() .map(shop -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());} è¿˜æœ‰ä¸€ç§æ–¹å¼å°±æ˜¯ä½¿ç”¨å¼‚æ­¥è¯·æ±‚CompletableFutureï¼š 123456789101112131415161718public List&lt;String&gt; findPrice(String product) { List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product)) )) .collect(Collectors.toList()); /* * è¿™é‡Œåˆ†ä¸ºä¸¤ä¸ªstreamè¿›è¡Œå¤„ç†çš„åŸå› æ˜¯: * å¦‚æœåœ¨ç¬¬ä¸€ä¸ªstreamå¤„ç›´æ¥æ¥ä¸Šmap(CompletableFuture::join)ï¼Œ * ä¼šé€ æˆå‘shop1å‘é€getPriceçš„è¯·æ±‚å¹¶è¿”å›futureåï¼Œé©¬ä¸Šå°±è°ƒç”¨joinæŠŠå½“å‰threadé˜»å¡ï¼Œå»ç­‰å¾…shop1è¿”å›çš„ç»“æœã€‚ * å¯¼è‡´æ‰§è¡Œè¿‡ç¨‹å˜ä¸ºshop1.getprice() -&gt; join() -&gt; shop2.getprice() -&gt; join -&gt; ...ï¼Œ * æ²¡æœ‰çœŸæ­£åˆ©ç”¨åˆ°asyncçš„ç‰¹ç‚¹ã€‚ */ return priceFutures.stream() .map(CompletableFuture::join) .collect(Collectors.toList());} å½“shopçš„æ•°é‡ä¸º4ä¸”ä¸¤ä¸ªæ–¹æ³•åœ¨4æ ¸CPUä¸Šè¿è¡Œæ—¶ï¼Œparallelçš„æ–¹æ³•è€—æ—¶çº¦ä¸º1sï¼Œè€Œasyncæ–¹æ³•è€—æ—¶çº¦ä¸º2sã€‚è¿™é‡Œæ˜¯å› ä¸ºasyncéœ€è¦threadsä¹‹é—´çš„å¯¹CPUå’Œå†…å­˜çš„ç«äº‰ä»¥åŠä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚å¦‚æœå­˜åœ¨5ä¸ªshopï¼Œé‚£ä¹ˆparallelçš„æƒ…å†µä¸‹éœ€è¦è€—æ—¶çº¦2sï¼Œå› ä¸ºéœ€è¦ç­‰å¾…4ä¸ªå…ˆå‰çš„å¹¶è¡Œä»»åŠ¡ä¸­çš„æŸä¸ªå®Œæˆåæ‰èƒ½å‘èµ·æ–°çš„taskã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œasyncå¯ä»¥é€šè¿‡å®šä¹‰custom executorçš„æ–¹å¼æ¥scaleã€‚ 123456789101112131415161718192021private final Executor executor = Executors.newFixedThreadPool( // é˜²æ­¢shopsæ•°é‡è¿‡å¤šä½¿å¾—çº¿ç¨‹æ± å¯å…è®¸çš„threadsæ•°é‡å¤ªå¤š // threadsæ•°é‡å¤ªå¤šä¼šé€ æˆå¤§é‡å¯¹CPUå’Œå†…å­˜çš„ç«äº‰ä»¥åŠä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ Math.min(shops.size(), 100), new ThreadFactory() { @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); /* * A Java program canâ€™t terminate or exit while a normal thread is executing, * so a leftover thread waiting for a never-satisfiable event causes problems. * By contrast, marking a thread as a daemon means it can be killed on program termination. */ thread.setDaemon(true); return thread; } });// å°†custom executorç”¨äºfindPriceä¸­çš„CompletableFutureCompletableFuture.supplyAsync( () -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), shop.getPrice(product), executor); åœ¨ä½¿ç”¨custom executorçš„æƒ…å†µä¸‹ï¼Œasyncæ–¹æ³•ä¸­å¯ä»¥å‘èµ·çš„threadsæ•°é‡ä¸å†å±€é™äºCPUæ ¸å¿ƒæ•°ï¼Œå†åŠ ä¸ŠgetPriceä¸»è¦æ˜¯Network I/Oï¼Œå³ç­‰å¾…è¿œç«¯æœåŠ¡å™¨è®¡ç®—è¿”å›ç»“æœï¼Œthreadè‡ªèº«åªè´Ÿè´£å‘èµ·è¯·æ±‚ä½†æ²¡æœ‰å¯†é›†çš„è®¡ç®—ï¼Œå³ä½¿shopsæ•°é‡è¾¾åˆ°400ï¼Œä¹Ÿå¯ä»¥åœ¨çº¦ä¸º1så†…è·å¾—æ‰€æœ‰çš„pricesã€‚ å¯¹äºä½¿ç”¨parallelè¿˜æ˜¯asyncï¼Œä¸»è¦å–å†³äºtaskæ˜¯ä»¥computeä¸ºä¸»ï¼Œè¿˜æ˜¯ä»¥waitä¸ºä¸»ï¼š If youâ€™re doing computation-heavy operations with no I/O, then the Stream interface gives the simplest implementation and one likely to be the most efficient (if all threads are compute-bound, then thereâ€™s no point in having more threads than processor cores). On the other hand, if your parallel units of work involve waiting for I/O (including network connections), then CompletableFutures give more flexibility and the ability to match the number of threads to the wait/computer, or W/C, ratio. Combine independent asynchronous tasks (11.4)One frequently occurring case is where you need to combine the results of the operations performed by two completely independent CompletableFutures, and you donâ€™t want to wait for the first to complete before starting on the second. Turning to our running example, you may know that one of the shops provides prices in â‚¬(EUR), but you always want to communicate them in $ (USD) to your customers. You can asynchronously ask the shop the price of a given product and retrieve, from a remote exchange-rate service, the current exchange rate between â‚¬ and $. After both have completed, you can combine the results by multiplying the price by the exchange rate. The implementation could be: 1234567Future&lt;Double&gt; futurePriceInUSD = CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product)) .thenCombine( CompletableFuture.supplyAsync( () -&gt; exchangeService.getRate(Money.EUR, Money.USD)), (price, rate) -&gt; price * rate ); The workflow of combining these two asynchronous tasks should be: Reacting to a CompletableFuture completion (11.5)åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå‘ä¸åŒçš„shopè¯·æ±‚getPriceï¼Œå“åº”æ—¶é—´ä¹Ÿå„ä¸ç›¸åŒã€‚æœ‰æ—¶å€™æˆ‘ä»¬æƒ³è¦å®ç°ä¸€æ—¦ä»æŸä¸ªshopè·å–çš„priceè¢«è¿”å›ï¼Œæˆ‘ä»¬å°±å¯ä»¥ç«‹åˆ»ä½¿ç”¨è¿™ä¸ªpriceï¼Œè€Œä¸éœ€è¦ç­‰å¾…æ‰€æœ‰taskséƒ½è¢«å®Œæˆåå†è¿›è¡Œä¸‹ä¸€æ­¥å¤„ç†ã€‚åœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨thenAcceptæ–¹æ³•ã€‚ 12345678910111213141516171819202122public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product) { return shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product), executor)) .map(future -&gt; future.thenApply(Quote::parse)) .map(future -&gt; future.thenCompose( quote -&gt; CompletableFuture.supplyAsync( () -&gt; Discount.applyDiscount(quote), executor)));}CompletableFuture[] futures = findPricesStream(&quot;myPhone&quot;) .map(f -&gt; f.thenAccept(System.out::println)) .toArray(size -&gt; new CompletableFuture[size]);/* * The allOf factory method * Input: an array of CompletableFutures * Return: CompletableFuture&lt;Void&gt; * thatâ€™s completed only when all the CompletableFutures passed have completed. * There is another method called anyOf() * it waits for the completion of only one of the CompletableFutures in an array. */CompletableFuture.allOf(futures).join(); thenAccept() operation simply registers an action on each CompletableFuture; this action consumes the value of the CompletableFuture as soon as it completes. It also has an Async variant schedules the execution of the Consumer passed to it on a new thread from the thread pool instead of directly performing it using the same thread that completed the CompletableFuture. Because the thenAccept method already specifies how to consume the result produced by the CompletableFuture when it becomes available, it returns a Completable-Future.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_10_11/"},{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(1)","text":"Java 8 in action ç¬¬ä¸€ç« è‡³ç¬¬ä¸‰ç« å­¦ä¹ ç¬”è®° Chapter 1. Java 8: why should you care?Stream in Unix commands (1.1.2)Note that in Unix the commands (cat, tr, sort, and tail) are executed concurrently, so that sort can be processing the first few lines before cat or tr has finished. (P.s. å¦‚åŒä¸€ä¸ªæµæ°´çº¿ä¸€æ ·ï¼Œåœ¨Step1å¤„ç†çš„åŒæ—¶ï¼Œå°±å°†å…¶å·²ç»ç”Ÿæˆçš„ä¸€éƒ¨åˆ†ç»“æœè¾“å…¥åˆ°Step2å»å¤„ç†ã€‚ï¼‰ Optional (1.5)Optional includes methods to explicitly deal with the case where a value is absent, and as a result you can avoid NullPointer exceptions. Chapter 2. Passing code with behavior parameterizationBehavior parameterizationBehavior parameterization is a software development pattern that lets you handle frequent requirement changes. In a nutshell, it means taking a block of code and making it available without executing it. This block of code can be called later by other parts of your programs, which means that you can defer the execution of that block of code. For instance, you could pass the block of code as an argument to another method that will execute it later. As a result, the methodâ€™s behavior is parameterized based on that block of code. Behavior parameterizationçš„å‘å±•ï¼ˆJavaï¼‰- ä»¥filterApplesä¸ºä¾‹ å¦‚æœæƒ³è¦ä»¥ä¸åŒæ ‡å‡†ï¼ˆé¢œè‰²ï¼Œé‡é‡â€¦ï¼‰æ¥è¿‡æ»¤ğŸï¼Œæœ€ç¬¨æ‹™çš„æ–¹æ³•æ˜¯å®šä¹‰å¤šä¸ªç›¸ä¼¼ä½†å¸¦æœ‰ä¸åŒåˆ¤æ–­é€»è¾‘çš„methodï¼Œè¿™æ ·ä¼šä½¿å¾—ä»£ç éå¸¸å†—ä½™ä¸”éš¾ä»¥ç»´æŠ¤ã€‚ ä½œä¸ºæ”¹è¿›ï¼Œå¯ä»¥å®šä¹‰ä¸€ä¸ªPredicate interfaceï¼Œç„¶åå®šä¹‰å¤šä¸ªä¸åŒçš„classå»implementè¿™ä¸ªinterfaceã€‚filterApples methodåˆ™å¯ä»¥æ¥æ”¶Predicateçš„instanceä½œä¸ºå‚æ•°æ¥å®ç°behavior parameterizationï¼Œbehavioræ˜¯é€šè¿‡è¢«wrapåœ¨instanceä¸­æ¥å®ç°ä¼ é€’çš„ã€‚ ä½†ä»¥ä¸Šæ–¹æ³•è¿˜æ˜¯éœ€è¦å®šä¹‰å¤šä¸ªclassesï¼Œå…¶ä¸­å¾ˆå¤šå¯èƒ½ä»…ä»…ä½¿ç”¨äº†ä¸€æ¬¡ã€‚ä¸ºäº†å‡å°‘verbosityï¼Œå¼•å…¥äº†anonymous classï¼Œå…è®¸ç¨‹åºå‘˜å®šä¹‰ad hoc classesã€‚ ä¸è¿‡anonymous classè¿˜æ˜¯æœ‰ä¸€éƒ¨åˆ†å†—ä½™çš„åœ°æ–¹ï¼Œæ¯”å¦‚æ¯æ¬¡éƒ½è¦å£°æ˜çˆ¶ç±»å’Œéœ€è¦overrideçš„æ–¹æ³•ã€‚lambda expressionçš„å‡ºç°è¿›ä¸€æ­¥ç®€åŒ–äº†è¿™ä¸€é—®é¢˜ï¼Œä¹‹åè¿˜è¡ç”Ÿå‡ºæ›´åŠ ç®€æ´çš„method referenceã€‚ Chapter 3. Lambda expressionsLambda syntax (Quiz 3.1)123456789// Illegal, return is a control-flow statement.// It should be (Integer i) -&gt; {return &quot;Alan&quot; + i;}(Integer i) -&gt; return &quot;Alan&quot; + i;// Illegal, â€œIron Manâ€ is an expression, not a statement.// It should be (String s) -&gt; &quot;Iron Man&quot; or (String s) -&gt; {return &quot;Iron Man&quot;;}.(String s) -&gt; {&quot;Iron Man&quot;;}// p.s. å¦‚æœæ˜¯statementï¼Œå°±ç®—åªæœ‰ä¸€å¥ä¹Ÿè¦åŠ ä¸Šblock Functional interfaces and Lambda expressions (3.2.1)Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline and treat the whole expression as an instance of a functional interface (more technically speaking, an instance of a concrete implementation of the functional interface). Execute around pattern (3.3)A recurrent pattern in resource processing (for example, dealing with files or databases) is to open a resource, do some processing on it, and then close the resource. The setup and cleanup phases are always similar and surround the important code doing the processing. This is called the execute around pattern. 1234567891011121314151617// execute around patternå¾ˆé€‚åˆç”¨lambdaè¿›è¡Œbehavior parameterization// define functional interfacepublic interface BufferedReaderProcessor { String process(BufferedReader b) throws IOException;}// define the method accept instance of the functional interfacepublic static String processFile (BufferedReaderProcessor p) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(&quot;data.txt&quot;))) { return p.process(br); }}// pass lambda expressionsString oneLine = processFile((BufferedReader br) -&gt; br.readLine());String twoLines = processFile((BufferedReader br) -&gt; br.readLine() + br.readLine()); Primitive specializations (3.4.3)Boxed values are essentially a wrapper around primitive types and are stored on the heap. Therefore, boxed values use more memory and require additional memory lookups to fetch the wrapped primitive value. Java 8 brings a specialized version of the functional interfaces in order to avoid autoboxing operations when the inputs or outputs are primitives. 1234567// no boxingIntPredicate evenNumbers = (int i) -&gt; i % 2 == 0;evenNumbers.test(1000);// with boxingPredicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % 2 == 1;oddNumbers.test(1000) type-checking process (3.5.1)Use filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150); as an example. First, you look up the declaration of the filter method. (filter(List&lt;Apple&gt; inventory, Predicate&lt;Apple&gt; p)) Second, it expects as the second formal parameter an object of type Predicate&lt;Apple&gt; (the target type ). Third, Predicate is a functional interface defining a single abstract method called test. Fourth, the method test describes a function descriptor that accepts an Apple and returns a boolean. Finally, any actual argument to the filter method needs to match this requirement. Special void-compatibility ruleIf a lambda has a statement expression as its body, itâ€™s compatible with a function descriptor that returns void (provided the parameter list is compatible too). For example, both of the following lines are legal even though the method add of a List returns a boolean and not void as expected in the Consumer context (T -&gt; void): 12345// Predicate has a boolean returnPredicate&lt;String&gt; p = s -&gt; list.add(s);// Consumer has a void returnConsumer&lt;String&gt; b = s -&gt; list.add(s); Recipe for constructing method references A method reference to a static method (Integer::parseInt) A method reference to an instance method of an arbitrary type (String::length) A method reference to an instance method of an existing object (expensiveTransaction::getValue, expensiveTransaction is an instance of type Transaction) 12345678910111213141. A method reference to a static methodLambda: (args) -&gt; ClassName.staticMethod(args) Method reference: ClassName::staticMethode.g. (String s) -&gt; Integer.parseInt(s) =&gt; Integer::parseInt2. A method reference to an instance method of an arbitrary typeLambda: (arg0, rest) -&gt; arg0.instanceMethod(rest) // arg0 is an instance of ClassNameMethod reference: ClassName::instanceMethode.g. (String s) -&gt; s.length() =&gt; String::length3. A method reference to an instance method of an existing objectLambda: (args) -&gt; expr.instanceMethod(args) // expr is an instance of some classMethod reference: expr::instanceMethode.g. () -&gt; expensiveTransaction.getValue() =&gt; expensiveTransaction::getValue","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_01_03/"},{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(2)","text":"Java 8 in action ç¬¬å…­ç« ã€ç¬¬ä¸ƒç« å­¦ä¹ ç¬”è®° Chapter 6. Collecting data with streamsJoining Strings (6.2.3)The collector returned by the joining factory method concatenates into a single string all strings resulting from invoking the toString method on each object in the stream. 1String shortMenu = menu.stream().map(Dish::getName).collect(joining()); Note that joining internally makes use of a StringBuilder to append the generated strings into one. It also has an overloaded version that accepts a delimiter string between two consecutive elements. 123String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;));// Result:// pork, beef, chicken, french fries, rice, season fruit, pizza, prawns, salmon Collect vs. reduce123456789Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();List&lt;Integer&gt; numbers = stream.reduce( new ArrayList&lt;Integer&gt;(), (List&lt;Integer&gt; l, Integer e) -&gt; { l.add(e); return l; }, (List&lt;Integer&gt; l1, List&lt;Integer&gt; l2) -&gt; { l1.addAll(l2); return l1; }); The semantic problem: reduce method is meant to combine two values and produce a new one; itâ€™s an immutable reduction. In contrast, the collect method is designed to mutate a container to accumulate the result itâ€™s supposed to produce. The practical problem: this reduction process canâ€™t work in parallel because the concurrent modification of the same data structure operated by multiple threads can corrupt the List itself. Multilevel grouping (6.3.1)You can achieve multilevel grouping by using a collector created with a two-argument version of the Collectors.groupingBy factory method, which accepts a second argument of type collector besides the usual classification function. 123456789101112131415161718192021public enum CaloricLevel { DIET, NORMAL, FAT };Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByTypeCaloricLevel = menu.stream().collect( // outer collector with classification function groupingBy(Dish::getType, // inner collector groupingBy(dish -&gt; { if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET; else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL; else return CaloricLevel.FAT; }) ) )/* * Result will be like: * {MEAT={DIET=[chicken], NORMAL=[beef], FAT=[pork]}, * FISH={DIET=[prawns], NORMAL=[salmon]}, * OTHER={DIET=[rice, seasonal fruit], NORMAL=[french fries, pizza]}} */ The regular one-argument groupingBy(f), where f is the classification function, is in reality just shorthand for groupingBy(f, toList()). More generally, the second collector passed to the first groupingBy can be any type of collector, not just another groupingBy. 123456789101112131415// count the number of Dishes in the menu for each type// {MEAT=3, FISH=2, OTHER=4}Map&lt;Dish.Type, Long&gt; typesCount = menu.stream().collect( groupingBy(Dish::getType, counting()));// find the highest-calorie dish in the menu// {FISH=salmon, OTHER=pizza, MEAT=pork}// å› ä¸ºmaxByè¿”å›çš„æ˜¯Optionalï¼Œæ­¤å¤„éœ€è¦ç”¨collectingAndThenå°†maxByå’ŒOptional::getåŒ…èµ·æ¥// å…¶ä¸­ï¼ŒmaxByè¿”å›ä¸€ä¸ªcollectorï¼ŒOptional::getæ˜¯transformation functionï¼ŒcollectingAndThenä¹Ÿè¿”å›ä¸€ä¸ªcollectorã€‚Map&lt;Dish.Type, Dish&gt; mostCaloricType = menu.stream() .collect(groupingBy(Dish::getType, collectingAndThen( maxBy(comparingInt(Dish::getCalories)), Optional::get))); Chapter 7. Parallel data processing and performanceparallel() (7.1.1)In reality, calling the method parallel on a sequential stream doesnâ€™t imply any concrete transformation on the stream itself. Internally, a boolean flag is set to signal that you want to run in parallel all the operations that follow the invocation to parallel. For the code: 123456stream.parallel() .filter(...) .sequential() .map(...) .parallel() .reduce(); Only the last call to parallel or sequential wins and affects the pipeline globally. Threads on multiple cores (7.1.2)Moving data between multiple cores is also more expensive than you might expect, so itâ€™s important that work to be done in parallel on another core takes longer than the time required to transfer the data from one core to another. ForkJoinPool (7.2.1) Note that in a real-world application, it doesnâ€™t make sense to use more than one ForkJoinPool. For this reason, what you typically should do is instantiate it only once and keep this instance in a static field, making it a singleton, so it could be conveniently reused by any part of your software. Invoking the join method on a task blocks the caller until the result produced by that task is ready. For this reason, itâ€™s necessary to call it after the computation of both subtasks has been started. Calling the fork method on a subtask is the way to schedule it on the ForkJoinPool. It might seem natural to invoke it on both the left and right subtasks,** but this is less efficient than just directly calling compute on one of them.** Doing this allows you to reuse the same thread for one of the two subtasks and avoid the overhead caused by the unnecessary allocation of a further task on the pool. Work stealing (7.2.3)Ideally you want to partition the workload of a parallelized task in a way that each subtask takes exactly the same amount of time, keeping all the cores of your CPU equally busy. However, the time taken by each subtask can dramatically vary either due to the use of an inefficient partition strategy or because of unpredictable causes like slow access to the disk or the need to coordinate the execution with external services. The fork/join framework works around this problem with a technique called work stealing. Each of the threads holds a doubly linked queue of the tasks assigned to it, and as soon as it completes a task it pulls another one from the head of the queue and starts executing it. One thread might complete all the tasks assigned to it much faster than the others, in this case, instead of becoming idle, the thread randomly chooses a queue of a different thread and â€œstealsâ€ a task, taking it from the tail of the queue. Itâ€™s why having many smaller tasks, instead of only a few bigger ones, can help in better balancing the workload among the worker threads. More generally, this work-stealing algorithm is used to redistribute and balance the tasks among the worker threads in the pool.","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_06_07/"},{"title":"Java 8 in action å­¦ä¹ ç¬”è®°(3)","text":"Java 8 in action ç¬¬å…«ç« ã€ç¬¬ä¹ç« å­¦ä¹ ç¬”è®° Chapter 8. Refactoring, testing, and debuggingAnonymous classes &amp; Lambda expressions (8.1.2) Inside an anonymous class, this refers to the anonymous class itself, but inside a lambda it refers to the enclosing class. Anonymous classes are allowed to shadow variables from the enclosing class. Lambda expressions canâ€™t (theyâ€™ll cause a compile error). 123456789101112131415int a = 10;// LambdaRunnable r1 = () -&gt; { int a = 2; // Compile error System.out.println(a);};// Anonymous classRunnable r2 = new Runnable() { public void run() { int a = 2; // fine! System.out.println(a); }}; Converting an anonymous class to a lambda expression can make the resulting code ambiguous in the context of overloading. 1234567891011121314151617181920212223interface Task{ // execute() has the same signature as run() in Runnable public void execute();}// there are 2 overloaded methods inside a classpublic static void doSomething(Runnable r){ r.run(); }public static void doSomething(Task a){ r.execute(); }// Anonymous class// will call doSomething(Task)doSomething(new Task() { public void execute() { System.out.println(&quot;Danger danger!!&quot;); }});// Lambda// Both doSomething(Task) and doSomething(Runnable) matchdoSomething(() -&gt; System.out.println(&quot;Danger danger!!&quot;));// The ambiguity can be solved by explicit castdoSomething((Task)() -&gt; System.out.println(&quot;Danger danger!!&quot;)); Conditional deferred execution (8.1.5)1234567891011121314151617181920212223// Example 1// 1. The state of the logger (what level it supports) is exposed in the client code through the method isLoggable.// 2. Query the state of the logger object every time before you can log a message// å¦‚æœéœ€è¦åœ¨å¤šå¤„è¿›è¡Œlogï¼Œå°±è¦å°†è¿™ä¸ªé€»è¾‘é‡å¤å¤šæ¬¡ï¼Œç›¸å½“ç¹çif (logger.isLoggable(Log.FINER)){ logger.finer(&quot;Problem: &quot; + generateDiagnostic());}// Example 2// è¿™ç§å†™æ³•ä½¿å¾—éœ€è¦logä¸åŒçº§åˆ«çš„æ—¥å¿—æ—¶ï¼Œåªéœ€è¦ä¿®æ”¹ä¸€ä¸‹Level.xxxå³å¯ã€‚// Unfortunately, thereâ€™s still an issue with this code. The logging message is always evaluated, even if the logger isnâ€™t enabled for the message level passed as argument.logger.log(Level.FINER, &quot;Problem: &quot; + generateDiagnostic());// Example 3// lambdaå®ç°äº†å½“log levelåŒ¹é…æ—¶ï¼Œlogä¿¡æ¯æ‰ä¼šè¢«ç”Ÿæˆã€‚// å¦‚æœä½ å‘ç°ä»£ç ä¸­å¤šæ¬¡å‡ºç°äº†åˆ¤æ–­æŸä¸ªinstanceçš„çŠ¶æ€ï¼Œä»…ä¸ºäº†è¿›å…¥conditionå»è°ƒç”¨æŸäº›methodçš„æ¨¡å¼ï¼Œå°±å¯ä»¥è€ƒè™‘å¼•å…¥ä¸€ä¸ªæ–°çš„methodå’Œlambdaï¼Œå°†ä¸Šè¿°æ“ä½œå°è£…åœ¨æ–°methodé‡Œã€‚public void log(Level level, Supplier&lt;String&gt; msgSupplier) { if (logger.isLoggable(level)){ log(level, msgSupplier.get()); }}logger.log(Level.FINER, () -&gt; &quot;Problem: &quot; + generateDiagnostic()); Design Pattern â€“ Strategy (8.2.1)123456789101112131415161718192021// é€šè¿‡functional interface + lambdaå¯ä»¥å¿«é€Ÿå®šä¹‰å¤šä¸ªstrategyã€‚// åŒæ—¶ï¼Œè®©client classè°ƒç”¨interfaceä¸­çš„abstract methodã€‚// è¿™æ ·å°±å¯ä»¥é€šè¿‡ä¼ å…¥ä¸åŒçš„lambdaæ¥æ”¹å˜methodçš„è¡Œä¸ºï¼Œä»è€Œå®ç°åœ¨runtimeç¡®å®šç©¶ç«Ÿæ‰§è¡Œå“ªä¸€å¥—é€»è¾‘ã€‚public interface ValidationStrategy { boolean execute(String s);}public class Validator { private final ValidationStrategy strategy; public Validator (ValidationStrategy v) this.strategy = v; public boolean validate (String s) { return strategy.execute(s); }}Validator numericValidator = new Validator((String s) -&gt; s.matches(&quot;[0-9]+&quot;));boolean b1 = numericValidator.validate(&quot;aaaa&quot;); // return falseValidator lowerCaseValidator = new Validator((String s) -&gt; s.matches(&quot;\\\\d+&quot;));boolean b2 = lowerCaseValidator.validate(&quot;bbbb&quot;); // return true Chain of responsibility (8.2.4)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// One processing object may do some work and pass the result to another object, which then also does some work and passes it on to yet another processing object, and so on.// Generally, this pattern is implemented by defining an abstract class representing a processing object that defines a field to keep track of a successor. Once it has finished its work, the processing object hands over its work to its successor.// abstract class represents the processing objectpublic abstract class ProcessingObject&lt;T&gt; { // to track the successor object which will do further processing based on current result protected ProcessingObject&lt;T&gt; successor; public void setSuccessor(ProcessingObject&lt;T&gt; successor) { this.successor = successor; } public T handle(T input) { T r = handleWork(input); if (successor != null) { return successor.handle(r); } return r; } abstract protected T handleWork(T input);}public class HeaderTextProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return &quot;From Raoul, Mario and Alan: &quot; + text; }}public class SpellCheckerProcessing extends ProcessingObject&lt;String&gt; { public String handleWork(String text) { return text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;); }}// Use in clientProcessingObject&lt;String&gt; p1 = new HeaderTextProcessing();ProcessingObject&lt;String&gt; p2 = new SpellCheckerProcessing();p1.setSuccessor(p2);String result1 = p1.handle(&quot;Aren't labdas really sexy?!!&quot;); // Result: From Raoul, Mario and Alan: Aren't lambda really sexy?!!// Turn to lambda implementationUnaryOperator&lt;String&gt; headerProcessing = (String text) -&gt; &quot;From Raoul, Mario and Alan: &quot; + text;UnaryOperator&lt;String&gt; spellCheckerProcessing = (String text) -&gt; text.replaceAll(&quot;labda&quot;, &quot;lambda&quot;);Function&lt;String, String&gt; pipeline = headerProcessing.andThen(spellCheckerProcessing);String result2 = pipeline.apply(&quot;Aren't labdas really sexy?!!&quot;); Chapter 9. Default methodsBinary Compatible (9.1.2)Adding a new method to an interface is binary compatible; this means existing class file implementations will still run without the implementation of the new method, if thereâ€™s no attempt to recompile them. If the user modify the code to use the new method (say setRelativeSize), an error will be thrown at run-time because the setRelativeSize method isnâ€™t implemented: 12Exception in thread &quot;main&quot; java.lang.AbstractMethodError: lambdasinaction.chap9.Ellipse.setRelativeSize(II)V If the user tries to rebuild his entire application, heâ€™ll get the following compile error: 1lambdasinaction/chap9/Ellipse.java:6: error: Ellipse is not abstract and does not override abstract method setRelativeSize(int,int) in Resizable Source compatibility &amp; Behavioral compatibility Source compatibility: source compatibility means an existing program will still compile after introducing a change.(e.g. adding a method to an interface isnâ€™t source compatible) Behavioral compatibility: behavioral compatibility means running a program after a change with the same inputs results in the same behavior.(e.g. adding a method to an interface is behavioral compatible because the method is never called in the program) Resolution rules (9.4) Classes always win. A method declaration in the class or a superclass takes priority over any default method declaration. Otherwise, sub-interfaces win: the method with the same signature in the most specific default-providing interface is selected. (If B extends A, B is more specific than A). Finally, if the choice is still ambiguous, the class inheriting from multiple interfaces has to explicitly select which default method implementation to use by overriding it and calling the desired method explicitly. 12345678910111213141516171819202122232425262728293031323334// Example 1// A is an interface with method hello(), B is another interface extends A and override hello(), D is a class implements Apublic class D implements A {}public class C extends D implements B, A { public static void main (String[] args) { // hello() from B is called // Because D doesnâ€™t override hello although it has a default method from interface A. And B is more specfic than A. new C().hello(); }}// Example 2public interface A { void hello() { System.out.println(&quot;Hello from A&quot;); }}public interface B { void hello() { System.out.println(&quot;Hello from B&quot;); }}// Error: class C inherits unrelated defaults for hello() from types B and A.public class C implements B, A { }// Solution: use X.super.m() where X is the superinterface whose method m you want to call.public class C implements B, A { void hello() { B.super.hello(); // explicitly choose to call hello() from B }}","link":"/2021/01/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java_8_in_action/Java_8_in_action_Chapter_08_09/"},{"title":"1. Course overview + the shell","text":"The Missing Semester of Your CS Education (2020): Lesson 1 1. Course overview + the shellMeanings of rwx of directory r æŒ‡çš„æ˜¯èƒ½å¦æµè§ˆæ–‡ä»¶å¤¹é‡Œçš„å†…å®¹ï¼ˆto list its contentsï¼‰ w æŒ‡çš„æ˜¯èƒ½å¦æ·»åŠ æˆ–åˆ é™¤æ–‡ä»¶å¤¹é‡Œçš„å†…å®¹ï¼ˆe.g. add/remove files in itï¼‰ï¼Œä½†è¿˜æ˜¯å¯ä»¥ä¿®æ”¹æ–‡ä»¶å¤¹ä¸­çš„æŸä¸€æ–‡ä»¶çš„å†…å®¹ï¼ˆåœ¨å¯¹è¯¥æ–‡ä»¶æœ‰æƒé™çš„å‰æä¸‹ï¼‰ x æŒ‡çš„æ˜¯èƒ½å¦è¿›å…¥è¯¥æ–‡ä»¶å¤¹ To enter a directory, a user must have â€œsearchâ€ (represented by â€œexecuteâ€: x) permissions on that directory (and its parents) Why sudo echo 500 &gt; brightness still causes permission denied? Operations like |, &gt;, and &lt; are done by the shell, not by the individual program. echo and friends do not â€œknowâ€ about |. They just read from their input and write to their output, whatever it may be. In the case above, the shell (which is authenticated just as your user) tries to open the brightness file for writing, before setting that as sudo echoâ€™s output, but is prevented from doing so since the shell does not run as root. sudo echo 500 only gives current shell the root permission to execute echo command, but it still doesnâ€™t have the permission for open&amp;write brightness. echo 1060 | sudo tee brightness Since the tee program is the one to open the /sys file for writing, and it is running as root, the permissions all work out. tee: takes its input and writes it to a file, but also to the stdout. It can be used when you want to send something into a file but also want to see it to yourself. xdg-open ä½¿ç”¨ xdg-open æ‰“å¼€æ–‡ä»¶æ—¶ï¼Œä¼šè‡ªåŠ¨ä½¿ç”¨æœ€åˆé€‚çš„ç¨‹åºå»æ‰“å¼€è¿™ä¸ªæ–‡ä»¶ã€‚æ¯”å¦‚ xdg-open xxx.html ä¼šç”¨æµè§ˆå™¨æ‰“å¼€è¿™ä¸ªhtmlæ–‡ä»¶ï¼Œç›¸å½“äºæˆ‘ä»¬ç”¨åŒå‡»é¼ æ ‡æ‰“å¼€æ–‡ä»¶çš„æ•ˆæœã€‚ Shell The shell is a programming environment, just like Python or Ruby, and so it has variables, conditionals, loops, and functions. When we run the echo command, the shell sees that it should execute the program echo, and then searches through the :-separated list of directories in $PATH for a file by that name. When it finds it, it runs it (assuming the file is executable). Run the command by explicitly starting the sh interpreter, and giving it the file semester as the first argument, i.e. sh semester.","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/1_Course%20overview_+_the_shell/"},{"title":"2. Shell Tools and Scripting","text":"The Missing Semester of Your CS Education (2020): Lesson 2 2. Shell Tools and ScriptingA seris of special variables $0 - Name of the script $1 to $9 - Arguments to the script. $1 is the first argument and so on $@ - All the arguments $# - Number of arguments $? - Return code of the previous command (A value of 0 usually means everything went OK; anything different from 0 means an error occurred.) $$ - Process identification number (PID) for the current script 12345678910111213141516171819#!/bin/bash# Command substitution: date will be substitute# Use $(command) to refer to the output of the comanndecho &quot;Starting program at $(date)&quot;echo &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null/ 2&gt; /dev/null # Redirect STDOUT and STDERR to a null register # When pattern is not found, grep has exit status 1 # When performing comparisons in bash, try to use double brackets [[ ]] in favor of simple brackets [ ]. if [[ &quot;$?&quot; -ne 0 ]]; then echo &quot;File $file doesn't have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone !! - Entire last command, including arguments. A common pattern is to execute a command only for it to fail due to missing permissions; you can quickly re-execute the command with sudo by doing sudo !! $_ - Last argument from the last command. If you are in an interactive shell, you can also quickly get this value by typing Esc followed by . Process substitution cat &lt;(ls) &lt;(ls ..) : &lt;( CMD ) will execute CMD and place the output in a temporary file and substitute the &lt;() with that fileâ€™s name. This example will print the list of contents in current dir and its parent dir. Shebang (#!) #!/usr/local/bin/python : The kernel knows to execute this script with a python interpreter instead of a shell command because we included a shebang line at the top of the script. #!/usr/bin/env python : Tell the kernel to run this script with env command. env will make use of the PATH environment variable to find python interpreter to execute this script, which increases the portability of your scripts. (Because python is not necessarily in /usr/local/bin/python) 4. TLDR Sometimes manpages can provide overly detailed descriptions of the commands, making it hard to decipher what flags/syntax to use for common use cases. TLDR pages are a nifty complementary solution that focuses on giving example use cases of a command so you can quickly figure out which options to use. CTRL + R In most shells, you can make use of Ctrl+R to perform backwards search through your history. After pressing Ctrl+R, you can type a substring you want to match for commands in your history. As you keep pressing it, you will cycle through the matches in your history. ExerciseQ1 Includes all files, including hidden files (ls -a) Sizes are listed in human readable format (e.g. 454M instead of 454279954) (ls -lh, -h means human-readable) Files are ordered by recency (ls -lt, -t means sort by modification time) Output is colorized (ls â€“color=auto) 12345678910111213[ngsuser@testenv101 /]$ ls -ltha --color=autototal 1.1Gdrwxr-xr-x. 30 root root 1000 Sep 13 07:41 rundrwxrwxrwt. 12 root root 4.0K Sep 12 13:16 tmpdrwxr-xr-x. 95 root root 8.0K Sep 11 14:18 etcdrwxr-xr-x. 5 ngsuser ngsgroup 107 Sep 11 03:37 data2drwxr-xr-x. 15 root root 178 Jul 16 09:54 usrdrwxr-xr-x. 5 root root 71 Jul 16 09:52 optdr-xr-xr-x. 178 root root 0 Jul 16 09:49 procdrwxr-xr-x. 20 root root 3.0K Jul 16 09:49 devdr-xr-xr-x. 13 root root 0 Jul 16 09:49 sysdrwxr-xr-x. 1 vagrant vagrant 288 Jul 16 09:39 vagrant... Q2 marco.sh 12345#!/bin/bashmarco() { export CUR_DIR=&quot;$(pwd)&quot;} polo.sh 12345#!/bin/bashpolo() { cd &quot;$CUR_DIR&quot;} Result 1234567891011[ngsuser@testenv101 ngsuser]$ pwd/home/ngsuser[ngsuser@testenv101 ngsuser]$ source marco.sh[ngsuser@testenv101 ngsuser]$ source polo.sh[ngsuser@testenv101 ngsuser]$ marco[ngsuser@testenv101 ngsuser]$ cd /[ngsuser@testenv101 /]$ pwd/[ngsuser@testenv101 /]$ polo[ngsuser@testenv101 ngsuser]$ pwd/home/ngsuser Q31234567891011#!/usr/bin/env bashfile=&quot;test_script.sh&quot;while [[ &quot;$?&quot; -ne 1 ]]; do ./$file 1&gt;&gt; run.log 2&gt;&gt; debug.logdoneecho &quot;$file runs $(cat run.log | wc -l) times&quot;&gt; run.log&gt; debug.log Q4123456789101112131415161718# When piping commands, we are connecting STDOUT to STDIN, but some commands like tar take inputs from arguments. # To bridge this disconnect thereâ€™s the xargs command which will execute a command using STDIN as arguments.# Recursively find all the markdown files# xargs will pass STDIN arguments to tar command# Because some files contain space in their names, we need to configure -d of xargs with &quot;\\n&quot;, means using &quot;\\n&quot; as delimiter[ngsuser@testenv101 missing-semester]$ find . -name &quot;*.md&quot; | xargs -d &quot;\\n&quot; tar -czf gzippack.tar.gz[ngsuser@testenv101 missing-semester]$ tar -xzf gzippack.tar.gz -C extract[ngsuser@testenv101 missing-semester]$ ls -R extract/extract/:_2019 _2020 about.md index.md license.md md with space.md README.mdextract/_2019:automation.md command-line.md data-wrangling.md editors.md os-customization.md program-introspection.md security.md version-control.md web.mdbackups.md course-overview.md dotfiles.md machine-introspection.md package-management.md remote-machines.md shell.md virtual-machines.mdextract/_2020:command-line.md course-shell.md data-wrangling.md debugging-profiling.md editors.md metaprogramming.md potpourri.md qa.md security.md shell-tools.md version-control.md Q512345# find all the files under current directory recursively# use xargs to pass files as arguments to ls command# head command gets the first record[ngsuser@testenv101 missing-semester]$ find . -type f | xargs -d &quot;\\n&quot; ls -lt | head -n 1-rw-r--r--. 1 ngsuser ngsgroup 288484 Sep 16 12:14 ./gzippack.tar.gz","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/2_Shell_Tools_and_Scripting/"},{"title":"4 Data Wrangling","text":"The Missing Semester of Your CS Education (2020): Lesson 4 4 Data WranglingSSHssh can send command to remote server and stream the result to local 12# use a pipe to stream a remote file through grep on our local computerssh myserver journalctl | grep sshd seds command: s/REGEX/SUBSTITUTION/. REGEX is the regular expression you want to search for, and SUBSTITUTION is the text you want to substitute matching text with. 12345# substitute the part end with &quot;Disconnected from &quot; in each line with emptyssh myserver journalctl | grep sshd | grep &quot;Disconnected from&quot; | sed 's/.*Disconnected from //' Regular expressions . means â€œany single characterâ€ except newline * zero or more of the preceding match + one or more of the preceding match [abc] any one character of a, b, and c (RX1|RX2) either something that matches RX1 or RX2 ^ the start of the line $ the end of the line * and + are, by default, â€œgreedyâ€. They will match as much text as they can. Suffix them with a ? to make them non-greedy in some implementations. (not sed) 123# If someone tried to log in with the username â€œDisconnected fromâ€Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]-&gt; 46.97.239.16 port 55920 [preauth] -&gt; user name lost () : capture groups 123# Because sed doesn't support ? to turn to non-greedy, we have to match the whole line# Substitute the matched str by the second capture group (\\2), which is (.*)... | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' awk The default pattern (which we used above) matches all lines. $0 is set to the entire lineâ€™s contents, and $1 through $n are set to the nth field of that line. Field separator (whitespace by default, change with -F) 12# here, for every line, print the contents of the second field... | awk '{print $2}' The pattern says that the first field of the line should be equal to 1, and that the second field should match the given regular expression. 12# Compute the number of single-use usernames that start with c and end with e... | awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' | wc -l BEGIN is a pattern that matches the start of the input (and END matches the end). 12345# Now, the per-line block just adds the count from the first field,# and then we print it out at the end.BEGIN { rows = 0 }$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }END { print rows } ExerciseQ1.1: Matching a decimal numbers12345678910Match 3.14529Match -255.34Match 128Match 1.9e10Match 123,340.00Skip 720pSolution: ^-?\\d+(,\\d+)*(\\.\\d+(e\\d+)?)?$P.s. (e\\d+)?éœ€è¦åŒ…å«åœ¨(\\.\\d+...)?é‡Œé¢ï¼Œæ˜¯å› ä¸ºå¦‚æœå‡ºç°ç§‘å­¦è®¡æ•°æ³•ï¼Œeä¹‹å‰å¿…å®šæœ‰å°æ•°ç‚¹ã€‚ å¦‚æœä¸åŒ…å«èµ·æ¥ï¼Œ19e10è¿™æ ·çš„ä¹Ÿä¼šè¢«åŒ¹é…åˆ°ã€‚ Q1.2: Matching phone numbers123456789Capture 415-555-1234 415Capture 650-555-2345 650Capture (416)555-3456 416Capture 202 555 4567 202Capture 4035555678 403Capture 1 416 555 9292 416Solution: 1?[\\s-]?\\(?(\\d{3})\\)?[\\s-]?\\d{3}[\\s-]?\\d{4}æ€è·¯: å…ˆç”¨1?[\\s-]?å¤„ç†country codeï¼Œä¹‹åå°±æŒ‰ç…§æ­£å¸¸çš„3ï¼Œ3ï¼Œ4çš„ç»“æ„å»å¤„ç†ã€‚ Q1.3: Matching emails123456789Capture tom@hogwarts.com tomCapture tom.riddle@hogwarts.com tom.riddleCapture tom.riddle+regexone@hogwarts.com tom.riddleCapture tom@hogwarts.eu.com tomCapture potter@hogwarts.com potterCapture harry@hogwarts.com harryCapture hermione+regexone@hogwarts.comSolution: ^([\\w\\.]*) Q1.4: Capturing HTML Tags123456Capture &lt;a&gt;This is a link&lt;/a&gt; aCapture &lt;a href='https://regexone.com'&gt;Link&lt;/a&gt; aCapture &lt;div class='test_style'&gt;Test&lt;/div&gt; divCapture &lt;div&gt;Hello &lt;span&gt;world&lt;/span&gt;&lt;/div&gt; divSolution: &lt;(\\w+) Q1.5: Capturing Filename Data12345678910Skip .bash_profileSkip workspace.docCapture img0912.jpg img0912 jpgCapture updated_img0912.png updated_img0912 pngSkip documentation.htmlCapture favicon.gif favicon gifSkip img0912.jpg.tmpSkip access.lockSolution: (\\w+)\\.(jpg|png|gif)$ Q1.6: Trimming whitespace from start and end of line1234Capture The quick brown fox... The quick brown fox... Capture jumps over the lazy dog. jumps over the lazy dog.Solution: ^\\s*(.*)\\s*$ Q1.7: Extracting Data From Log Entries12345678Skip W/dalvikvm( 1553): threadid=1: uncaught exceptionSkip E/( 1553): FATAL EXCEPTION: mainSkip E/( 1553): java.lang.StringIndexOutOfBoundsExceptionCapture E/( 1553): at widget.List.makeView(ListView.java:1727) makeView ListView.java 1727Capture E/( 1553): at widget.List.fillDown(ListView.java:652) fillDown ListView.java 652Capture E/( 1553): at widget.List.fillFrom(ListView.java:709) fillFrom ListView.java 709Solution: (\\w+)\\(([\\w\\.]+):(\\d+)\\) Q1.8: Extracting Data From URLs1234567Capture ftp://file_server.com:21/top_secret/life_changing_plans.pdf ftp file_server.com 21Capture https://regexone.com/lesson/introduction#section https regexone.comCapture file://localhost:4040/zip_file file localhost 4040Capture https://s3cur3-server.com:9999/ https s3cur3-server.com 9999Capture market://search/angry%20birds market searchSolution: (\\w+)://([\\w\\-\\.]+):?(\\d+)? Q2 What are the three most common last two letters of those words? 123456# å…ˆæ‰¾å‡ºåŒ…å«ä¸‰ä¸ªä»¥ä¸Šaçš„å­—ç¬¦ä¸²ï¼Œç„¶åå†grep -vé€†å‘matchä»¥'sç»“å°¾çš„å­—ç¬¦ä¸²# æ¥ç€ä½¿ç”¨sedè·å–æœ€åä¸¤ä¸ªå­—ç¬¦ï¼Œæœ€åå°±æ˜¯sortï¼Œå»é‡å¹¶ç»Ÿè®¡æ•°é‡ï¼ŒæŒ‰ç¬¬ä¸€åˆ—é€†å‘æ’åºï¼Œå–å¤´3ä¸ªå³å¯cat words | grep '.*[aA].*[aA].*[aA]' | grep -v &quot;.*'s$&quot; | sed -E 's/.*(.{2})$/\\1/' | sort | uniq -c | sort -rk1 |head -n31039 al 814 ia 763 an How many of those two-letter combinations are there? 12cat words | grep '.*[aA].*[aA].*[aA]' | grep -v &quot;.*'s$&quot; | sed -E 's/.*(.{2})$/\\1/' | sort | uniq -c | wc -l156 Q3 ä¸ºä»€ä¹ˆ sed s/REGEX/SUBSTITUTION/ input.txt &gt; input.txt è¿™æ ·çš„åšæ³•ä¸å¥½ï¼Ÿå› ä¸º &gt; ä¼šå…ˆæŠŠç›®æ ‡æ–‡ä»¶æ¸…ç©ºï¼Œç„¶åè¯»å–æ‰§è¡Œcommandåäº§ç”Ÿçš„è¾“å‡ºå¹¶å†™å…¥ç›®æ ‡æ–‡ä»¶ã€‚åœ¨è¿™ä¸ªæƒ…å†µä¸‹ï¼Œinput.txtè¢«æ¸…ç©ºåå°±æ²¡åŠæ³•æ­£ç¡®åŒ¹é…åˆ°å†…å®¹ï¼Œæœ€åinput.txtä¼šå˜æˆç©ºçš„ã€‚å¯ä»¥å†™å…¥å…¶ä»–çš„æ–‡ä»¶æˆ–æ˜¯ä½¿ç”¨ -i é€‰é¡¹ã€‚","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/4_Data_Wrangling/"},{"title":"5. Command Line Environment","text":"The Missing Semester of Your CS Education (2020): Lesson 5 5. Command Line EnvironmentJob Control1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# Ctrl-Z -&gt; SIGSTOP, stop or pause current process$ sleep 1000^Z[1] + 18653 suspended sleep 1000# launch process with nohup (a wrapper to ignore SIGHUP)$ nohup sleep 2000 &amp;[2] 18745appending output to nohup.out# list the unfinished jobs associated with the current terminal session$ jobs[1] + suspended sleep 1000[2] - running nohup sleep 2000# continue the paused job in the foreground or in the background using fg or bg# refer to a process using the percent symbol followed by its job number (displayed by jobs)# $!: the last backgrounded job$ bg %1[1] - 18653 continued sleep 1000$ jobs[1] - running sleep 1000[2] + running nohup sleep 2000# you can also send SIGSTOP signal with kill command$ kill -STOP %1[1] + 18653 suspended (signal) sleep 1000$ jobs[1] + suspended (signal) sleep 1000[2] - running nohup sleep 2000# because %1 cannot handle SIGHUP, it will be stopped/killed$ kill -SIGHUP %1[1] + 18653 hangup sleep 1000$ jobs[2] + running nohup sleep 2000$ kill -SIGHUP %2# %2 ignores SIGHUP, it will keep running$ jobs[2] + running nohup sleep 2000$ kill %2[2] + 18745 terminated nohup sleep 2000$ jobs &amp; : &amp; suffix in a command will run the command in the background, giving you the prompt back Backgrounded processes are still children processes of your terminal and will die if you close the terminal (this will send yet another signal, SIGHUP). pgrep: find out pid of jobs Terminal Multiplexers (tmux) tmux has keybindings with the form &lt;C-b&gt; + x (prefix key followed by a command key): (1) press Ctrl+b, (2) release Ctrl+b, and then (3) press x. (Ctrl+b can be rebinding to other key like Ctrl+a) Sessions 12345tmux: starts a new session.tmux new -s NAME: starts it with that name.tmux ls: lists the current sessionsWithin tmux typing &lt;C-b&gt; d: detaches the current sessiontmux a: attaches the last session. You can use -t flag to specify which Windows 123456&lt;C-b&gt; c: Creates a new window. To close it you can just terminate the shells doing &lt;C-d&gt;&lt;C-b&gt; N: Go to the N th window. Note they are numbered&lt;C-b&gt; p: Goes to the previous window&lt;C-b&gt; n: Goes to the next window&lt;C-b&gt; ,: Rename the current window&lt;C-b&gt; w: List current windows Panes 123456&lt;C-b&gt; &quot;: Split the current pane horizontally&lt;C-b&gt; %: Split the current pane vertically&lt;C-b&gt; &lt;direction&gt;: Move to the pane in the specified direction. Direction here means arrow keys.&lt;C-b&gt; z: Toggle zoom for the current pane&lt;C-b&gt; [: Start scrollback. You can then press &lt;space&gt; to start a selection and &lt;enter&gt; to copy that selection.&lt;C-b&gt; &lt;space&gt;: Cycle through pane arrangements. (è‡ªåŠ¨åˆ‡æ¢ä¸åŒçš„æ’åˆ—) Dotfiles Portability1234567if [[ &quot;$(uname)&quot; == &quot;Linux&quot; ]]; then {do_something}; fi# Check before using shell-specific featuresif [[ &quot;$SHELL&quot; == &quot;zsh&quot; ]]; then {do_something}; fi# You can also make it machine-specificif [[ &quot;$(hostname)&quot; == &quot;myServer&quot; ]]; then {do_something}; fi ExerciseQ1123456sleep 10000C-zbg %1# -a: list PID and full command linepgrep -af sleeppkill sleep Q21234567# wait only works for child processes# æ³¨æ„ä¸èƒ½ä½¿ç”¨pipe(|)ï¼Œå› ä¸ºpipeä¼šå¼€å¯ä¸€ä¸ªæ–°çš„subshell(bash)å»æ‰§è¡ŒæŒ‡ä»¤ã€‚# å°±ä¼šå¯¼è‡´sleep 60 &amp;æ˜¯å½“å‰shellçš„child processè€Œwait $! | lsæ˜¯subshellçš„child processã€‚[ngsuser@testenv101 ~]$ sleep 60 &amp; wait $! ; ls[1] 24522[1]+ Done sleep 60bin data dev_docs etc GSP-VERSION missing-semester nohup.out schema service-conf-packaged test-data tmux.py usr var VERSION","link":"/2021/01/06/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The_Missing_Semester_of_Your_CS_Education_2020/5_Command_Line_Environment/"},{"title":"Core Java Volume I å­¦ä¹ ç¬”è®°(1)","text":"Core Java Volume I ç¬¬ä¸ƒç« è‡³ç¬¬ä¹ç« å­¦ä¹ ç¬”è®° Chapter 7: Exceptions, Assertions, and Loggingchecked exceptionå’Œunchecked exceptionï¼Ÿassertionå’Œexceptionçš„ä¸åŒï¼Ÿä½¿ç”¨åœºæ™¯ï¼ŸChapter 8: Generic ProgrammingBridge method ï¼ˆ8.5.3 Translating Generic Methodsï¼‰é¦–å…ˆæˆ‘ä»¬æ¥åˆ†æordinary classçš„å¤šæ€ã€‚å‡è®¾æˆ‘ä»¬æœ‰å®šä¹‰äº†ä¸€ä¸ª DateInterval classå»ç»§æ‰¿ Pair classã€‚åœ¨ Pair ä¸­å­˜åœ¨ä¸€ä¸ª public void setSecond(Object second)ï¼Œè€Œæˆ‘ä»¬åœ¨ DateInterval ä¸­å®šä¹‰äº† public void setSecond(LocalDate second)ã€‚è¿™ç§æƒ…å†µä¸æ˜¯overrideè€Œæ˜¯overloadã€‚ 1234567891011class Pair{ public void setSecond(Object second) { . . . } . . .}class DateInterval extends Pair{ public void setSecond(LocalDate second) { . . . } . . .} ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬æ‰§è¡Œä»¥ä¸‹ä»£ç ï¼Œæœ€ç»ˆåœ¨runtimeè¢«æ‰§è¡Œçš„ä¹Ÿæ˜¯ä» Pair ç»§æ‰¿ä¸‹æ¥çš„ publicvoid setSecond(Object second)ã€‚ 1234DateInterval interval = new DateInterval(. . .);Pair pair = interval;// setSecond(Object second) but not setSecond(LocalDate second)pair.setSecond(aDate); æ¥ä¸‹æ¥æˆ‘ä»¬æŠŠæƒ…å†µæ‰©å±•åˆ°genericsçš„èŒƒç•´ï¼Œå³å­˜åœ¨ä¸€ä¸ªgeneric class Pair&lt;T&gt;, DateInterval ç»§æ‰¿äº† Pair&lt;LocalDate&gt;ï¼š 12345678910class DateInterval extends Pair&lt;LocalDate&gt;{ // override setSecond(LocalDate second) in Pair&lt;LocalDate&gt; (fromprogrammer's view) public void setSecond(LocalDate second) { if (second.compareTo(getFirst()) &gt;= 0) super.setSecond(second); } . . .} ä½†æ˜¯ï¼Œç”±äºcomplieræœ€ç»ˆä¼šæŠŠ type variable ç»™erasureäº†ï¼Œä¸Šè¿°ä»£ç å®é™…ä¸Šæ˜¯ï¼š 123456789class DateInterval extends Pair // after erasure{ // inherit from Pair public void setSecond(Object second) { . . . } // overload public void setSecond(LocalDate second) { . . . } . . .} åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœæ‰§è¡Œä»¥ä¸‹ä»£ç ï¼Œæ ¹æ®Javaå¤šæ€çš„è§„åˆ™ï¼Œè¢«è°ƒç”¨çš„åº”è¯¥æ˜¯ç»§æ‰¿ä¸‹æ¥çš„void setSecond(Object second)ï¼š 123DateInterval interval = new DateInterval(. . .);Pair&lt;LocalDate&gt; pair = interval; // OK--assignment to superclasspair.setSecond(aDate); // void setSecond(Object second) is called å¾ˆæ˜æ˜¾è¿™ä¸ªç»“æœä¸æ˜¯æˆ‘ä»¬æ‰€æœŸæœ›çš„ï¼Œtype erasure å½±å“äº†å¤šæ€ã€‚ä¸ºäº†ä¿®å¤è¿™ä¸€é—®é¢˜ï¼Œcomplierä¼šåœ¨ DateInterval è‡ªåŠ¨ç”Ÿæˆ bridge methodï¼š 12// call the defined setSecond(LocalDate second) through setSecond(Object second)public void setSecond(Object second) { setSecond((Date) second); } è¿™æ ·ä¸€æ¥ï¼Œå³ä½¿è¿›è¡Œäº†ç±»å‹æ“¦é™¤ï¼Œæœ€ç»ˆä¹Ÿèƒ½å¤Ÿè°ƒç”¨åˆ°æˆ‘ä»¬å®šä¹‰çš„ï¼Œæˆ‘ä»¬è®¤ä¸ºæ˜¯è¿›è¡Œäº†overrideçš„é‚£ä¸ªmethodã€‚ What is Wildcards in Java Generics for? (8.8 Wildcard Types) Generic classesä¹‹é—´æœ¬èº«ä¸å­˜åœ¨relationï¼Œä½†æ˜¯wildcardå¯ä»¥ä¸ä¸å®ƒä»¬äº§ç”Ÿsubtypeæˆ–è€…supertypeçš„relationã€‚è¯¦è§ï¼šJava Genericâ€™s Wildcards - Jenkov Tutorials Wildcard type instantiation example (8.8 Wildcard Types)1234567891011121314151617181920212223public class Pair&lt;T&gt; { private T first; private T second; public Pair(T first, T second) { this.first = first; this.second = second; } public T getFirst() { return first; } public T getSecond() { return second; } public static void main(String[] args) { // legal, è¯´æ˜wildcardåœ¨åˆå§‹åŒ–æ—¶å¹¶ä¸ä¼šè¦æ±‚ä¼ å…¥çš„firstå’Œsecondç±»å‹ä¸€è‡´ã€‚ Pair&lt;?&gt; pair = new Pair&lt;&gt;(1, &quot;happy&quot;); }} Chapter 9: Collectionsoff-by-one erroræ¯”å¦‚åœ¨å¾ªç¯çš„æ—¶å€™å¤šå¾ªç¯äº†ä¸€æ¬¡æˆ–æ˜¯å°‘å¾ªç¯äº†ä¸€æ¬¡å¯¼è‡´errorï¼Œè¿™ç±»å‹çš„errorå°±æ˜¯off-by-one errorã€‚ References: What is an off-by-one error and how do I fix it? - Answered by Mark Byers Off-by-one error - Wikipedia","link":"/2021/01/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Core_Java_Volume_I:_Fundamentals%20_10th_Edition/Core_Java_Volume_I_Chapter_07_09/"},{"title":"å¥½æ–‡æ”¶è—","text":"æ”¶è—ä¸€äº›çœ‹è¿‡çš„ä¼˜ç§€æ–‡ç« ï¼Œä¼˜ç§€å›ç­” å¥½æ–‡æ”¶è—Backpressure å¦‚ä½•å½¢è±¡çš„æè¿°ååº”å¼ç¼–ç¨‹ä¸­çš„èƒŒå‹(Backpressure)æœºåˆ¶ï¼Ÿâ€“ æ‰”ç‰©çº¿çš„å›ç­” Horizontal&amp;Vertical Scaling Difference between scaling horizontally and vertically for databases Unit test | Integration tests | Smoke tests | Regression tests What are unit tests, integration tests, smoke tests, and regression tests? Kerberos èƒ½ç”¨é€šç”¨çš„è¯­è¨€ä»‹ç»ä¸‹ Kerberos åè®®ä¹ˆï¼Ÿâ€“ è½¦å°èƒ–çš„å›ç­”","link":"/2021/01/06/%E5%A5%BD%E6%96%87%E6%94%B6%E8%97%8F/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Stream","slug":"Stream","link":"/tags/Stream/"},{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Optional","slug":"Optional","link":"/tags/Optional/"},{"name":"Future","slug":"Future","link":"/tags/Future/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Regex","slug":"Regex","link":"/tags/Regex/"},{"name":"Job control","slug":"Job-control","link":"/tags/Job-control/"},{"name":"Tmux","slug":"Tmux","link":"/tags/Tmux/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"Generic Programming","slug":"Generic-Programming","link":"/tags/Generic-Programming/"},{"name":"Collections","slug":"Collections","link":"/tags/Collections/"},{"name":"ç²¾é€‰æ–‡ç« ","slug":"ç²¾é€‰æ–‡ç« ","link":"/tags/%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0/"}],"categories":[{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Java 8 in action","slug":"è¯»ä¹¦ç¬”è®°/Java-8-in-action","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java-8-in-action/"},{"name":"è¯¾ç¨‹ç¬”è®°","slug":"è¯¾ç¨‹ç¬”è®°","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"The Missing Semester of Your CS Education (2020)","slug":"è¯¾ç¨‹ç¬”è®°/The-Missing-Semester-of-Your-CS-Education-2020","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/The-Missing-Semester-of-Your-CS-Education-2020/"},{"name":"Core Java Volume I","slug":"è¯»ä¹¦ç¬”è®°/Core-Java-Volume-I","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Core-Java-Volume-I/"},{"name":"ç²¾é€‰æ–‡ç« æ±‡æ€»","slug":"ç²¾é€‰æ–‡ç« æ±‡æ€»","link":"/categories/%E7%B2%BE%E9%80%89%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"}]}